// Code generated by go-swagger; DO NOT EDIT.

package containers

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LibpodGetContainerReader is a Reader for the LibpodGetContainer structure.
type LibpodGetContainerReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *LibpodGetContainerReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewLibpodGetContainerOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 404:
		result := NewLibpodGetContainerNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewLibpodGetContainerInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewLibpodGetContainerOK creates a LibpodGetContainerOK with default headers values
func NewLibpodGetContainerOK() *LibpodGetContainerOK {
	return &LibpodGetContainerOK{}
}

/*LibpodGetContainerOK handles this case with default header values.

Inspect container
*/
type LibpodGetContainerOK struct {
	Payload *LibpodGetContainerOKBody
}

func (o *LibpodGetContainerOK) Error() string {
	return fmt.Sprintf("[GET /libpod/containers/{name}/json][%d] libpodGetContainerOK  %+v", 200, o.Payload)
}

func (o *LibpodGetContainerOK) GetPayload() *LibpodGetContainerOKBody {
	return o.Payload
}

func (o *LibpodGetContainerOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(LibpodGetContainerOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewLibpodGetContainerNotFound creates a LibpodGetContainerNotFound with default headers values
func NewLibpodGetContainerNotFound() *LibpodGetContainerNotFound {
	return &LibpodGetContainerNotFound{}
}

/*LibpodGetContainerNotFound handles this case with default header values.

No such container
*/
type LibpodGetContainerNotFound struct {
	Payload *LibpodGetContainerNotFoundBody
}

func (o *LibpodGetContainerNotFound) Error() string {
	return fmt.Sprintf("[GET /libpod/containers/{name}/json][%d] libpodGetContainerNotFound  %+v", 404, o.Payload)
}

func (o *LibpodGetContainerNotFound) GetPayload() *LibpodGetContainerNotFoundBody {
	return o.Payload
}

func (o *LibpodGetContainerNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(LibpodGetContainerNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewLibpodGetContainerInternalServerError creates a LibpodGetContainerInternalServerError with default headers values
func NewLibpodGetContainerInternalServerError() *LibpodGetContainerInternalServerError {
	return &LibpodGetContainerInternalServerError{}
}

/*LibpodGetContainerInternalServerError handles this case with default header values.

Internal server error
*/
type LibpodGetContainerInternalServerError struct {
	Payload *LibpodGetContainerInternalServerErrorBody
}

func (o *LibpodGetContainerInternalServerError) Error() string {
	return fmt.Sprintf("[GET /libpod/containers/{name}/json][%d] libpodGetContainerInternalServerError  %+v", 500, o.Payload)
}

func (o *LibpodGetContainerInternalServerError) GetPayload() *LibpodGetContainerInternalServerErrorBody {
	return o.Payload
}

func (o *LibpodGetContainerInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(LibpodGetContainerInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*LibpodGetContainerInternalServerErrorBody libpod get container internal server error body
swagger:model LibpodGetContainerInternalServerErrorBody
*/
type LibpodGetContainerInternalServerErrorBody struct {

	// API root cause formatted for automated parsing
	Because string `json:"cause,omitempty"`

	// human error message, formatted for a human to read
	Message string `json:"message,omitempty"`

	// http response code
	ResponseCode int64 `json:"response,omitempty"`
}

// Validate validates this libpod get container internal server error body
func (o *LibpodGetContainerInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerNotFoundBody libpod get container not found body
swagger:model LibpodGetContainerNotFoundBody
*/
type LibpodGetContainerNotFoundBody struct {

	// API root cause formatted for automated parsing
	Because string `json:"cause,omitempty"`

	// human error message, formatted for a human to read
	Message string `json:"message,omitempty"`

	// http response code
	ResponseCode int64 `json:"response,omitempty"`
}

// Validate validates this libpod get container not found body
func (o *LibpodGetContainerNotFoundBody) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerNotFoundBody) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBody libpod get container o k body
swagger:model LibpodGetContainerOKBody
*/
type LibpodGetContainerOKBody struct {

	// app armor profile
	AppArmorProfile string `json:"AppArmorProfile,omitempty"`

	// args
	Args []string `json:"Args"`

	// bounding caps
	BoundingCaps []string `json:"BoundingCaps"`

	// config
	Config *LibpodGetContainerOKBodyConfig `json:"Config,omitempty"`

	// conmon pid file
	ConmonPidFile string `json:"ConmonPidFile,omitempty"`

	// created
	// Format: date-time
	Created strfmt.DateTime `json:"Created,omitempty"`

	// dependencies
	Dependencies []string `json:"Dependencies"`

	// driver
	Driver string `json:"Driver,omitempty"`

	// effective caps
	EffectiveCaps []string `json:"EffectiveCaps"`

	// exec i ds
	ExecIDs []string `json:"ExecIDs"`

	// exit command
	ExitCommand []string `json:"ExitCommand"`

	// graph driver
	GraphDriver *LibpodGetContainerOKBodyGraphDriver `json:"GraphDriver,omitempty"`

	// host config
	HostConfig *LibpodGetContainerOKBodyHostConfig `json:"HostConfig,omitempty"`

	// hostname path
	HostnamePath string `json:"HostnamePath,omitempty"`

	// hosts path
	HostsPath string `json:"HostsPath,omitempty"`

	// ID
	ID string `json:"Id,omitempty"`

	// image
	Image string `json:"Image,omitempty"`

	// image name
	ImageName string `json:"ImageName,omitempty"`

	// is infra
	IsInfra bool `json:"IsInfra,omitempty"`

	// log path
	LogPath string `json:"LogPath,omitempty"`

	// log tag
	LogTag string `json:"LogTag,omitempty"`

	// mount label
	MountLabel string `json:"MountLabel,omitempty"`

	// mounts
	Mounts []*LibpodGetContainerOKBodyMountsItems0 `json:"Mounts"`

	// name
	Name string `json:"Name,omitempty"`

	// namespace
	Namespace string `json:"Namespace,omitempty"`

	// network settings
	NetworkSettings *LibpodGetContainerOKBodyNetworkSettings `json:"NetworkSettings,omitempty"`

	// o c i config path
	OCIConfigPath string `json:"OCIConfigPath,omitempty"`

	// o c i runtime
	OCIRuntime string `json:"OCIRuntime,omitempty"`

	// path
	Path string `json:"Path,omitempty"`

	// pod
	Pod string `json:"Pod,omitempty"`

	// process label
	ProcessLabel string `json:"ProcessLabel,omitempty"`

	// resolv conf path
	ResolvConfPath string `json:"ResolvConfPath,omitempty"`

	// restart count
	RestartCount int32 `json:"RestartCount,omitempty"`

	// rootfs
	Rootfs string `json:"Rootfs,omitempty"`

	// size root fs
	SizeRootFs int64 `json:"SizeRootFs,omitempty"`

	// size rw
	SizeRw int64 `json:"SizeRw,omitempty"`

	// state
	State *LibpodGetContainerOKBodyState `json:"State,omitempty"`

	// static dir
	StaticDir string `json:"StaticDir,omitempty"`
}

// Validate validates this libpod get container o k body
func (o *LibpodGetContainerOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGraphDriver(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHostConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMounts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodGetContainerOKBody) validateConfig(formats strfmt.Registry) error {

	if swag.IsZero(o.Config) { // not required
		return nil
	}

	if o.Config != nil {
		if err := o.Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "Config")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodGetContainerOKBody) validateCreated(formats strfmt.Registry) error {

	if swag.IsZero(o.Created) { // not required
		return nil
	}

	if err := validate.FormatOf("libpodGetContainerOK"+"."+"Created", "body", "date-time", o.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *LibpodGetContainerOKBody) validateGraphDriver(formats strfmt.Registry) error {

	if swag.IsZero(o.GraphDriver) { // not required
		return nil
	}

	if o.GraphDriver != nil {
		if err := o.GraphDriver.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "GraphDriver")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodGetContainerOKBody) validateHostConfig(formats strfmt.Registry) error {

	if swag.IsZero(o.HostConfig) { // not required
		return nil
	}

	if o.HostConfig != nil {
		if err := o.HostConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodGetContainerOKBody) validateMounts(formats strfmt.Registry) error {

	if swag.IsZero(o.Mounts) { // not required
		return nil
	}

	for i := 0; i < len(o.Mounts); i++ {
		if swag.IsZero(o.Mounts[i]) { // not required
			continue
		}

		if o.Mounts[i] != nil {
			if err := o.Mounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "Mounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBody) validateNetworkSettings(formats strfmt.Registry) error {

	if swag.IsZero(o.NetworkSettings) { // not required
		return nil
	}

	if o.NetworkSettings != nil {
		if err := o.NetworkSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "NetworkSettings")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodGetContainerOKBody) validateState(formats strfmt.Registry) error {

	if swag.IsZero(o.State) { // not required
		return nil
	}

	if o.State != nil {
		if err := o.State.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "State")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBody) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyConfig InspectContainerConfig holds further data about how a container was initially
// configured.
swagger:model LibpodGetContainerOKBodyConfig
*/
type LibpodGetContainerOKBodyConfig struct {

	// Container annotations
	Annotations map[string]string `json:"Annotations,omitempty"`

	// Unused, at present
	AttachStderr bool `json:"AttachStderr,omitempty"`

	// Unused, at present
	AttachStdin bool `json:"AttachStdin,omitempty"`

	// Unused, at present
	AttachStdout bool `json:"AttachStdout,omitempty"`

	// Container command
	Cmd []string `json:"Cmd"`

	// CreateCommand is the full command plus arguments of the process the
	// container has been created with.
	CreateCommand []string `json:"CreateCommand"`

	// Container domain name - unused at present
	DomainName string `json:"Domainname,omitempty"`

	// Container entrypoint
	Entrypoint string `json:"Entrypoint,omitempty"`

	// Container environment variables
	Env []string `json:"Env"`

	// Container hostname
	Hostname string `json:"Hostname,omitempty"`

	// Container image
	Image string `json:"Image,omitempty"`

	// Container labels
	Labels map[string]string `json:"Labels,omitempty"`

	// On-build arguments - presently unused. More of Buildah's domain.
	OnBuild string `json:"OnBuild,omitempty"`

	// Whether the container leaves STDIN open
	OpenStdin bool `json:"OpenStdin,omitempty"`

	// Whether STDIN is only left open once.
	// Presently not supported by Podman, unused.
	StdinOnce bool `json:"StdinOnce,omitempty"`

	// Container stop signal
	StopSignal uint64 `json:"StopSignal,omitempty"`

	// SystemdMode is whether the container is running in systemd mode. In
	// systemd mode, the container configuration is customized to optimize
	// running systemd in the container.
	SystemdMode bool `json:"SystemdMode,omitempty"`

	// Timezone is the timezone inside the container.
	// Local means it has the same timezone as the host machine
	Timezone string `json:"Timezone,omitempty"`

	// Whether the container creates a TTY
	Tty bool `json:"Tty,omitempty"`

	// Umask is the umask inside the container.
	Umask string `json:"Umask,omitempty"`

	// User the container was launched with
	User string `json:"User,omitempty"`

	// Unused, at present. I've never seen this field populated.
	Volumes map[string]interface{} `json:"Volumes,omitempty"`

	// Container working directory
	WorkingDir string `json:"WorkingDir,omitempty"`

	// healthcheck
	Healthcheck *LibpodGetContainerOKBodyConfigHealthcheck `json:"Healthcheck,omitempty"`
}

// Validate validates this libpod get container o k body config
func (o *LibpodGetContainerOKBodyConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHealthcheck(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodGetContainerOKBodyConfig) validateHealthcheck(formats strfmt.Registry) error {

	if swag.IsZero(o.Healthcheck) { // not required
		return nil
	}

	if o.Healthcheck != nil {
		if err := o.Healthcheck.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "Config" + "." + "Healthcheck")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyConfig) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyConfigHealthcheck Schema2HealthConfig is a HealthConfig, which holds configuration settings
// for the HEALTHCHECK feature, from docker/docker/api/types/container.
swagger:model LibpodGetContainerOKBodyConfigHealthcheck
*/
type LibpodGetContainerOKBodyConfigHealthcheck struct {

	// Retries is the number of consecutive failures needed to consider a container as unhealthy.
	// Zero means inherit.
	Retries int64 `json:"Retries,omitempty"`

	// Test is the test to perform to check that the container is healthy.
	// An empty slice means to inherit the default.
	// The options are:
	// {} : inherit healthcheck
	// {"NONE"} : disable healthcheck
	// {"CMD", args...} : exec arguments directly
	// {"CMD-SHELL", command} : run command with system's default shell
	Test []string `json:"Test"`

	// A Duration represents the elapsed time between two instants
	// as an int64 nanosecond count. The representation limits the
	// largest representable duration to approximately 290 years.
	Interval int64 `json:"Interval,omitempty"`

	// A Duration represents the elapsed time between two instants
	// as an int64 nanosecond count. The representation limits the
	// largest representable duration to approximately 290 years.
	StartPeriod int64 `json:"StartPeriod,omitempty"`

	// A Duration represents the elapsed time between two instants
	// as an int64 nanosecond count. The representation limits the
	// largest representable duration to approximately 290 years.
	Timeout int64 `json:"Timeout,omitempty"`
}

// Validate validates this libpod get container o k body config healthcheck
func (o *LibpodGetContainerOKBodyConfigHealthcheck) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyConfigHealthcheck) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyConfigHealthcheck) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyConfigHealthcheck
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyGraphDriver Data handles the data for a storage driver
swagger:model LibpodGetContainerOKBodyGraphDriver
*/
type LibpodGetContainerOKBodyGraphDriver struct {

	// data
	Data map[string]string `json:"Data,omitempty"`

	// name
	Name string `json:"Name,omitempty"`
}

// Validate validates this libpod get container o k body graph driver
func (o *LibpodGetContainerOKBodyGraphDriver) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyGraphDriver) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyGraphDriver) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyGraphDriver
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfig InspectContainerHostConfig holds information used when the container was
// created.
// It's very much a Docker-specific struct, retained (mostly) as-is for
// compatibility. We fill individual fields as best as we can, inferring as much
// as possible from the spec and container config.
// Some things cannot be inferred. These will be populated by spec annotations
// (if available).
// Field names are fixed for compatibility and cannot be changed.
// As such, silence lint warnings about them.
// nolint
swagger:model LibpodGetContainerOKBodyHostConfig
*/
type LibpodGetContainerOKBodyHostConfig struct {

	// AutoRemove is whether the container will be automatically removed on
	// exiting.
	// It is not handled directly within libpod and is stored in an
	// annotation.
	AutoRemove bool `json:"AutoRemove,omitempty"`

	// Binds contains an array of user-added mounts.
	// Both volume mounts and named volumes are included.
	// Tmpfs mounts are NOT included.
	// In 'docker inspect' this is separated into 'Binds' and 'Mounts' based
	// on how a mount was added. We do not make this distinction and do not
	// include a Mounts field in inspect.
	// Format: <src>:<destination>[:<comma-separated options>]
	Binds []string `json:"Binds"`

	// BlkioDeviceReadBps is an array of I/O throttle parameters for
	// individual device nodes.
	// This specifically sets read rate cap in bytes per second for device
	// nodes.
	// As with BlkioWeightDevice, we pull the path from /sys/dev, and we
	// don't guarantee the path will be identical to the original (though
	// the node will be).
	BlkioDeviceReadBps []*LibpodGetContainerOKBodyHostConfigBlkioDeviceReadBpsItems0 `json:"BlkioDeviceReadBps"`

	// BlkioDeviceReadIOps is an array of I/O throttle parameters for
	// individual device nodes.
	// This specifically sets the read rate cap in iops per second for
	// device nodes.
	// As with BlkioWeightDevice, we pull the path from /sys/dev, and we
	// don't guarantee the path will be identical to the original (though
	// the node will be).
	BlkioDeviceReadIOps []*LibpodGetContainerOKBodyHostConfigBlkioDeviceReadIOpsItems0 `json:"BlkioDeviceReadIOps"`

	// BlkioDeviceWriteBps is an array of I/O throttle parameters for
	// individual device nodes.
	// this specifically sets write rate cap in bytes per second for device
	// nodes.
	// as with BlkioWeightDevice, we pull the path from /sys/dev, and we
	// don't guarantee the path will be identical to the original (though
	// the node will be).
	BlkioDeviceWriteBps []*LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteBpsItems0 `json:"BlkioDeviceWriteBps"`

	// BlkioDeviceWriteIOps is an array of I/O throttle parameters for
	// individual device nodes.
	// This specifically sets the write rate cap in iops per second for
	// device nodes.
	// As with BlkioWeightDevice, we pull the path from /sys/dev, and we
	// don't guarantee the path will be identical to the original (though
	// the node will be).
	BlkioDeviceWriteIOps []*LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteIOpsItems0 `json:"BlkioDeviceWriteIOps"`

	// BlkioWeight indicates the I/O resources allocated to the container.
	// It is a relative weight in the scheduler for assigning I/O time
	// versus other CGroups.
	BlkioWeight uint16 `json:"BlkioWeight,omitempty"`

	// BlkioWeightDevice is an array of I/O resource priorities for
	// individual device nodes.
	// Unfortunately, the spec only stores the device's Major/Minor numbers
	// and not the path, which is used here.
	// Fortunately, the kernel provides an interface for retrieving the path
	// of a given node by major:minor at /sys/dev/. However, the exact path
	// in use may not be what was used in the original CLI invocation -
	// though it is guaranteed that the device node will be the same, and
	// using the given path will be functionally identical.
	BlkioWeightDevice []*LibpodGetContainerOKBodyHostConfigBlkioWeightDeviceItems0 `json:"BlkioWeightDevice"`

	// CapAdd is a list of capabilities added to the container.
	// It is not directly stored by Libpod, and instead computed from the
	// capabilities listed in the container's spec, compared against a set
	// of default capabilities.
	CapAdd []string `json:"CapAdd"`

	// CapDrop is a list of capabilities removed from the container.
	// It is not directly stored by libpod, and instead computed from the
	// capabilities listed in the container's spec, compared against a set
	// of default capabilities.
	CapDrop []string `json:"CapDrop"`

	// Cgroup contains the container's cgroup. It is presently not
	// populated.
	// TODO.
	Cgroup string `json:"Cgroup,omitempty"`

	// CgroupConf is the configuration for cgroup v2.
	CgroupConf map[string]string `json:"CgroupConf,omitempty"`

	// CgroupMode is the configuration of the container's cgroup namespace.
	// Populated as follows:
	// private - a cgroup namespace has been created
	// host - No cgroup namespace created
	// container:<id> - Using another container's cgroup namespace
	// ns:<path> - A path to a cgroup namespace has been specified
	CgroupMode string `json:"CgroupMode,omitempty"`

	// CgroupParent is the CGroup parent of the container.
	// Only set if not default.
	CgroupParent string `json:"CgroupParent,omitempty"`

	// Cgroups contains the container's CGroup mode.
	// Allowed values are "default" (container is creating CGroups) and
	// "disabled" (container is not creating CGroups).
	// This is Libpod-specific and not included in `docker inspect`.
	Cgroups string `json:"Cgroups,omitempty"`

	// ConsoleSize is an array of 2 integers showing the size of the
	// container's console.
	// It is only set if the container is creating a terminal.
	// TODO.
	ConsoleSize []uint64 `json:"ConsoleSize"`

	// ContainerIDFile is a file created during container creation to hold
	// the ID of the created container.
	// This is not handled within libpod and is stored in an annotation.
	ContainerIDFile string `json:"ContainerIDFile,omitempty"`

	// CpuCount is Windows-only and not presently implemented.
	CPUCount uint64 `json:"CpuCount,omitempty"`

	// CpuPercent is Windows-only and not presently implemented.
	CPUPercent uint64 `json:"CpuPercent,omitempty"`

	// CpuPeriod is the length of a CPU period in microseconds.
	// It relates directly to CpuQuota.
	CPUPeriod uint64 `json:"CpuPeriod,omitempty"`

	// CpuPeriod is the amount of time (in microseconds) that a container
	// can use the CPU in every CpuPeriod.
	CPUQuota int64 `json:"CpuQuota,omitempty"`

	// CpuRealtimePeriod is the length of time (in microseconds) of the CPU
	// realtime period. If set to 0, no time will be allocated to realtime
	// tasks.
	CPURealtimePeriod uint64 `json:"CpuRealtimePeriod,omitempty"`

	// CpuRealtimeRuntime is the length of time (in microseconds) allocated
	// for realtime tasks within every CpuRealtimePeriod.
	CPURealtimeRuntime int64 `json:"CpuRealtimeRuntime,omitempty"`

	// CpuShares indicates the CPU resources allocated to the container.
	// It is a relative weight in the scheduler for assigning CPU time
	// versus other CGroups.
	CPUShares uint64 `json:"CpuShares,omitempty"`

	// CpusetCpus is the is the set of CPUs that the container will execute
	// on. Formatted as `0-3` or `0,2`. Default (if unset) is all CPUs.
	CpusetCpus string `json:"CpusetCpus,omitempty"`

	// CpusetMems is the set of memory nodes the container will use.
	// Formatted as `0-3` or `0,2`. Default (if unset) is all memory nodes.
	CpusetMems string `json:"CpusetMems,omitempty"`

	// Devices is a list of device nodes that will be added to the
	// container.
	// These are stored in the OCI spec only as type, major, minor while we
	// display the host path. We convert this with /sys/dev, but we cannot
	// guarantee that the host path will be identical - only that the actual
	// device will be.
	Devices []*LibpodGetContainerOKBodyHostConfigDevicesItems0 `json:"Devices"`

	// DiskQuota is the maximum amount of disk space the container may use
	// (in bytes).
	// Presently not populated.
	// TODO.
	DiskQuota uint64 `json:"DiskQuota,omitempty"`

	// Dns is a list of DNS nameservers that will be added to the
	// container's resolv.conf
	DNS []string `json:"Dns"`

	// DnsOptions is a list of DNS options that will be set in the
	// container's resolv.conf
	DNSOptions []string `json:"DnsOptions"`

	// DnsSearch is a list of DNS search domains that will be set in the
	// container's resolv.conf
	DNSSearch []string `json:"DnsSearch"`

	// ExtraHosts contains hosts that will be aded to the container's
	// etc/hosts.
	ExtraHosts []string `json:"ExtraHosts"`

	// GroupAdd contains groups that the user inside the container will be
	// added to.
	GroupAdd []string `json:"GroupAdd"`

	// IOMaximumBandwidth is Windows-only and not presently implemented.
	IOMaximumBandwidth uint64 `json:"IOMaximumBandwidth,omitempty"`

	// IOMaximumIOps is Windows-only and not presently implemented.
	IOMaximumIOps uint64 `json:"IOMaximumIOps,omitempty"`

	// Init indicates whether the container has an init mounted into it.
	Init bool `json:"Init,omitempty"`

	// IpcMode represents the configuration of the container's IPC
	// namespace.
	// Populated as follows:
	// "" (empty string) - Default, an IPC namespace will be created
	// host - No IPC namespace created
	// container:<id> - Using another container's IPC namespace
	// ns:<path> - A path to an IPC namespace has been specified
	IpcMode string `json:"IpcMode,omitempty"`

	// Isolation is presently unused and provided solely for Docker
	// compatibility.
	Isolation string `json:"Isolation,omitempty"`

	// KernelMemory is the maximum amount of memory the kernel will devote
	// to the container.
	KernelMemory int64 `json:"KernelMemory,omitempty"`

	// Links is unused, and provided purely for Docker compatibility.
	Links []string `json:"Links"`

	// Memory indicates the memory resources allocated to the container.
	// This is the limit (in bytes) of RAM the container may use.
	Memory int64 `json:"Memory,omitempty"`

	// MemoryReservation is the reservation (soft limit) of memory available
	// to the container. Soft limits are warnings only and can be exceeded.
	MemoryReservation int64 `json:"MemoryReservation,omitempty"`

	// MemorySwap is the total limit for all memory available to the
	// container, including swap. 0 indicates that there is no limit to the
	// amount of memory available.
	MemorySwap int64 `json:"MemorySwap,omitempty"`

	// MemorySwappiness is the willingness of the kernel to page container
	// memory to swap. It is an integer from 0 to 100, with low numbers
	// being more likely to be put into swap.
	// 1, the default, will not set swappiness and use the system defaults.
	MemorySwappiness int64 `json:"MemorySwappiness,omitempty"`

	// NanoCpus indicates number of CPUs allocated to the container.
	// It is an integer where one full CPU is indicated by 1000000000 (one
	// billion).
	// Thus, 2.5 CPUs (fractional portions of CPUs are allowed) would be
	// 2500000000 (2.5 billion).
	// In 'docker inspect' this is set exclusively of two further options in
	// the output (CpuPeriod and CpuQuota) which are both used to implement
	// this functionality.
	// We can't distinguish here, so if CpuQuota is set to the default of
	// 100000, we will set both CpuQuota, CpuPeriod, and NanoCpus. If
	// CpuQuota is not the default, we will not set NanoCpus.
	NanoCpus int64 `json:"NanoCpus,omitempty"`

	// NetworkMode is the configuration of the container's network
	// namespace.
	// Populated as follows:
	// default - A network namespace is being created and configured via CNI
	// none - A network namespace is being created, not configured via CNI
	// host - No network namespace created
	// container:<id> - Using another container's network namespace
	// ns:<path> - A path to a network namespace has been specified
	NetworkMode string `json:"NetworkMode,omitempty"`

	// OomKillDisable indicates whether the kernel OOM killer is disabled
	// for the container.
	OomKillDisable bool `json:"OomKillDisable,omitempty"`

	// OOMScoreAdj is an adjustment that will be made to the container's OOM
	// score.
	OomScoreAdj int64 `json:"OomScoreAdj,omitempty"`

	// PidMode represents the configuration of the container's PID
	// namespace.
	// Populated as follows:
	// "" (empty string) - Default, a PID namespace will be created
	// host - No PID namespace created
	// container:<id> - Using another container's PID namespace
	// ns:<path> - A path to a PID namespace has been specified
	PidMode string `json:"PidMode,omitempty"`

	// PidsLimit is the maximum number of PIDs what may be created within
	// the container. 0, the default, indicates no limit.
	PidsLimit int64 `json:"PidsLimit,omitempty"`

	// PortBindings contains the container's port bindings.
	// It is formatted as map[string][]InspectHostPort.
	// The string key here is formatted as <integer port number>/<protocol>
	// and represents the container port. A single container port may be
	// bound to multiple host ports (on different IPs).
	PortBindings map[string][]LibpodGetContainerOKBodyHostConfigPortBindingsItems0 `json:"PortBindings,omitempty"`

	// Privileged indicates whether the container is running with elevated
	// privileges.
	// This has a very specific meaning in the Docker sense, so it's very
	// difficult to decode from the spec and config, and so is stored as an
	// annotation.
	Privileged bool `json:"Privileged,omitempty"`

	// PublishAllPorts indicates whether image ports are being published.
	// This is not directly stored in libpod and is saved as an annotation.
	PublishAllPorts bool `json:"PublishAllPorts,omitempty"`

	// ReadonlyRootfs is whether the container will be mounted read-only.
	ReadonlyRootfs bool `json:"ReadonlyRootfs,omitempty"`

	// Runtime is provided purely for Docker compatibility.
	// It is set unconditionally to "oci" as Podman does not presently
	// support non-OCI runtimes.
	Runtime string `json:"Runtime,omitempty"`

	// SecurityOpt is a list of security-related options that are set in the
	// container.
	SecurityOpt []string `json:"SecurityOpt"`

	// ShmSize is the size of the container's SHM device.
	ShmSize int64 `json:"ShmSize,omitempty"`

	// Tmpfs is a list of tmpfs filesystems that will be mounted into the
	// container.
	// It is a map of destination path to options for the mount.
	Tmpfs map[string]string `json:"Tmpfs,omitempty"`

	// UTSMode represents the configuration of the container's UID
	// namespace.
	// Populated as follows:
	// "" (empty string) - Default, a UTS namespace will be created
	// host - no UTS namespace created
	// container:<id> - Using another container's UTS namespace
	// ns:<path> - A path to a UTS namespace has been specified
	UTSMode string `json:"UTSMode,omitempty"`

	// Ulimits is a set of ulimits that will be set within the container.
	Ulimits []*LibpodGetContainerOKBodyHostConfigUlimitsItems0 `json:"Ulimits"`

	// UsernsMode represents the configuration of the container's user
	// namespace.
	// When running rootless, a user namespace is created outside of libpod
	// to allow some privileged operations. This will not be reflected here.
	// Populated as follows:
	// "" (empty string) - No user namespace will be created
	// private - The container will be run in a user namespace
	// container:<id> - Using another container's user namespace
	// ns:<path> - A path to a user namespace has been specified
	// TODO Rootless has an additional 'keep-id' option, presently not
	// reflected here.
	UsernsMode string `json:"UsernsMode,omitempty"`

	// VolumeDriver is presently unused and is retained for Docker
	// compatibility.
	VolumeDriver string `json:"VolumeDriver,omitempty"`

	// VolumesFrom is a list of containers which this container uses volumes
	// from. This is not handled directly within libpod and is stored in an
	// annotation.
	// It is formatted as an array of container names and IDs.
	VolumesFrom []string `json:"VolumesFrom"`

	// log config
	LogConfig *LibpodGetContainerOKBodyHostConfigLogConfig `json:"LogConfig,omitempty"`

	// restart policy
	RestartPolicy *LibpodGetContainerOKBodyHostConfigRestartPolicy `json:"RestartPolicy,omitempty"`
}

// Validate validates this libpod get container o k body host config
func (o *LibpodGetContainerOKBodyHostConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBlkioDeviceReadBps(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBlkioDeviceReadIOps(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBlkioDeviceWriteBps(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBlkioDeviceWriteIOps(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBlkioWeightDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDevices(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePortBindings(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUlimits(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRestartPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateBlkioDeviceReadBps(formats strfmt.Registry) error {

	if swag.IsZero(o.BlkioDeviceReadBps) { // not required
		return nil
	}

	for i := 0; i < len(o.BlkioDeviceReadBps); i++ {
		if swag.IsZero(o.BlkioDeviceReadBps[i]) { // not required
			continue
		}

		if o.BlkioDeviceReadBps[i] != nil {
			if err := o.BlkioDeviceReadBps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "BlkioDeviceReadBps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateBlkioDeviceReadIOps(formats strfmt.Registry) error {

	if swag.IsZero(o.BlkioDeviceReadIOps) { // not required
		return nil
	}

	for i := 0; i < len(o.BlkioDeviceReadIOps); i++ {
		if swag.IsZero(o.BlkioDeviceReadIOps[i]) { // not required
			continue
		}

		if o.BlkioDeviceReadIOps[i] != nil {
			if err := o.BlkioDeviceReadIOps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "BlkioDeviceReadIOps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateBlkioDeviceWriteBps(formats strfmt.Registry) error {

	if swag.IsZero(o.BlkioDeviceWriteBps) { // not required
		return nil
	}

	for i := 0; i < len(o.BlkioDeviceWriteBps); i++ {
		if swag.IsZero(o.BlkioDeviceWriteBps[i]) { // not required
			continue
		}

		if o.BlkioDeviceWriteBps[i] != nil {
			if err := o.BlkioDeviceWriteBps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "BlkioDeviceWriteBps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateBlkioDeviceWriteIOps(formats strfmt.Registry) error {

	if swag.IsZero(o.BlkioDeviceWriteIOps) { // not required
		return nil
	}

	for i := 0; i < len(o.BlkioDeviceWriteIOps); i++ {
		if swag.IsZero(o.BlkioDeviceWriteIOps[i]) { // not required
			continue
		}

		if o.BlkioDeviceWriteIOps[i] != nil {
			if err := o.BlkioDeviceWriteIOps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "BlkioDeviceWriteIOps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateBlkioWeightDevice(formats strfmt.Registry) error {

	if swag.IsZero(o.BlkioWeightDevice) { // not required
		return nil
	}

	for i := 0; i < len(o.BlkioWeightDevice); i++ {
		if swag.IsZero(o.BlkioWeightDevice[i]) { // not required
			continue
		}

		if o.BlkioWeightDevice[i] != nil {
			if err := o.BlkioWeightDevice[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "BlkioWeightDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateDevices(formats strfmt.Registry) error {

	if swag.IsZero(o.Devices) { // not required
		return nil
	}

	for i := 0; i < len(o.Devices); i++ {
		if swag.IsZero(o.Devices[i]) { // not required
			continue
		}

		if o.Devices[i] != nil {
			if err := o.Devices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "Devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validatePortBindings(formats strfmt.Registry) error {

	if swag.IsZero(o.PortBindings) { // not required
		return nil
	}

	for k := range o.PortBindings {

		if err := validate.Required("libpodGetContainerOK"+"."+"HostConfig"+"."+"PortBindings"+"."+k, "body", o.PortBindings[k]); err != nil {
			return err
		}

		for i := 0; i < len(o.PortBindings[k]); i++ {

			if err := o.PortBindings[k][i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "PortBindings" + "." + k + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateUlimits(formats strfmt.Registry) error {

	if swag.IsZero(o.Ulimits) { // not required
		return nil
	}

	for i := 0; i < len(o.Ulimits); i++ {
		if swag.IsZero(o.Ulimits[i]) { // not required
			continue
		}

		if o.Ulimits[i] != nil {
			if err := o.Ulimits[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "Ulimits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateLogConfig(formats strfmt.Registry) error {

	if swag.IsZero(o.LogConfig) { // not required
		return nil
	}

	if o.LogConfig != nil {
		if err := o.LogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "LogConfig")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodGetContainerOKBodyHostConfig) validateRestartPolicy(formats strfmt.Registry) error {

	if swag.IsZero(o.RestartPolicy) { // not required
		return nil
	}

	if o.RestartPolicy != nil {
		if err := o.RestartPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "HostConfig" + "." + "RestartPolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfig) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigBlkioDeviceReadBpsItems0 InspectBlkioThrottleDevice holds information about a speed cap for a device
// node. This cap applies to a specific operation (read, write, etc) on the given
// node.
swagger:model LibpodGetContainerOKBodyHostConfigBlkioDeviceReadBpsItems0
*/
type LibpodGetContainerOKBodyHostConfigBlkioDeviceReadBpsItems0 struct {

	// Path is the path to the device this applies to.
	Path string `json:"Path,omitempty"`

	// Rate is the maximum rate. It is in either bytes per second or iops
	// per second, determined by where it is used - documentation will
	// indicate which is appropriate.
	Rate uint64 `json:"Rate,omitempty"`
}

// Validate validates this libpod get container o k body host config blkio device read bps items0
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceReadBpsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceReadBpsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceReadBpsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigBlkioDeviceReadBpsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigBlkioDeviceReadIOpsItems0 InspectBlkioThrottleDevice holds information about a speed cap for a device
// node. This cap applies to a specific operation (read, write, etc) on the given
// node.
swagger:model LibpodGetContainerOKBodyHostConfigBlkioDeviceReadIOpsItems0
*/
type LibpodGetContainerOKBodyHostConfigBlkioDeviceReadIOpsItems0 struct {

	// Path is the path to the device this applies to.
	Path string `json:"Path,omitempty"`

	// Rate is the maximum rate. It is in either bytes per second or iops
	// per second, determined by where it is used - documentation will
	// indicate which is appropriate.
	Rate uint64 `json:"Rate,omitempty"`
}

// Validate validates this libpod get container o k body host config blkio device read i ops items0
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceReadIOpsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceReadIOpsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceReadIOpsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigBlkioDeviceReadIOpsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteBpsItems0 InspectBlkioThrottleDevice holds information about a speed cap for a device
// node. This cap applies to a specific operation (read, write, etc) on the given
// node.
swagger:model LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteBpsItems0
*/
type LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteBpsItems0 struct {

	// Path is the path to the device this applies to.
	Path string `json:"Path,omitempty"`

	// Rate is the maximum rate. It is in either bytes per second or iops
	// per second, determined by where it is used - documentation will
	// indicate which is appropriate.
	Rate uint64 `json:"Rate,omitempty"`
}

// Validate validates this libpod get container o k body host config blkio device write bps items0
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteBpsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteBpsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteBpsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteBpsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteIOpsItems0 InspectBlkioThrottleDevice holds information about a speed cap for a device
// node. This cap applies to a specific operation (read, write, etc) on the given
// node.
swagger:model LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteIOpsItems0
*/
type LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteIOpsItems0 struct {

	// Path is the path to the device this applies to.
	Path string `json:"Path,omitempty"`

	// Rate is the maximum rate. It is in either bytes per second or iops
	// per second, determined by where it is used - documentation will
	// indicate which is appropriate.
	Rate uint64 `json:"Rate,omitempty"`
}

// Validate validates this libpod get container o k body host config blkio device write i ops items0
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteIOpsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteIOpsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteIOpsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigBlkioDeviceWriteIOpsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigBlkioWeightDeviceItems0 InspectBlkioWeightDevice holds information about the relative weight
// of an individual device node. Weights are used in the I/O scheduler to give
// relative priority to some accesses.
swagger:model LibpodGetContainerOKBodyHostConfigBlkioWeightDeviceItems0
*/
type LibpodGetContainerOKBodyHostConfigBlkioWeightDeviceItems0 struct {

	// Path is the path to the device this applies to.
	Path string `json:"Path,omitempty"`

	// Weight is the relative weight the scheduler will use when scheduling
	// I/O.
	Weight uint16 `json:"Weight,omitempty"`
}

// Validate validates this libpod get container o k body host config blkio weight device items0
func (o *LibpodGetContainerOKBodyHostConfigBlkioWeightDeviceItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioWeightDeviceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigBlkioWeightDeviceItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigBlkioWeightDeviceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigDevicesItems0 InspectDevice is a single device that will be mounted into the container.
swagger:model LibpodGetContainerOKBodyHostConfigDevicesItems0
*/
type LibpodGetContainerOKBodyHostConfigDevicesItems0 struct {

	// CgroupPermissions is the permissions of the mounted device.
	// Presently not populated.
	// TODO.
	CgroupPermissions string `json:"CgroupPermissions,omitempty"`

	// PathInContainer is the path of the device within the container.
	PathInContainer string `json:"PathInContainer,omitempty"`

	// PathOnHost is the path of the device on the host.
	PathOnHost string `json:"PathOnHost,omitempty"`
}

// Validate validates this libpod get container o k body host config devices items0
func (o *LibpodGetContainerOKBodyHostConfigDevicesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigDevicesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigDevicesItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigDevicesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigLogConfig InspectLogConfig holds information about a container's configured log driver
// and is presently unused. It is retained for Docker compatibility.
swagger:model LibpodGetContainerOKBodyHostConfigLogConfig
*/
type LibpodGetContainerOKBodyHostConfigLogConfig struct {

	// config
	Config map[string]string `json:"Config,omitempty"`

	// type
	Type string `json:"Type,omitempty"`
}

// Validate validates this libpod get container o k body host config log config
func (o *LibpodGetContainerOKBodyHostConfigLogConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigLogConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigLogConfig) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigLogConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigPortBindingsItems0 InspectHostPort provides information on a port on the host that a container's
// port is bound to.
swagger:model LibpodGetContainerOKBodyHostConfigPortBindingsItems0
*/
type LibpodGetContainerOKBodyHostConfigPortBindingsItems0 struct {

	// IP on the host we are bound to. "" if not specified (binding to all
	// IPs).
	HostIP string `json:"HostIp,omitempty"`

	// Port on the host we are bound to. No special formatting - just an
	// integer stuffed into a string.
	HostPort string `json:"HostPort,omitempty"`
}

// Validate validates this libpod get container o k body host config port bindings items0
func (o *LibpodGetContainerOKBodyHostConfigPortBindingsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigPortBindingsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigPortBindingsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigPortBindingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigRestartPolicy InspectRestartPolicy holds information about the container's restart policy.
swagger:model LibpodGetContainerOKBodyHostConfigRestartPolicy
*/
type LibpodGetContainerOKBodyHostConfigRestartPolicy struct {

	// MaximumRetryCount is the maximum number of retries allowed if the
	// "on-failure" restart policy is in use. Not used if "on-failure" is
	// not set.
	MaximumRetryCount uint64 `json:"MaximumRetryCount,omitempty"`

	// Name contains the container's restart policy.
	// Allowable values are "no" or "" (take no action),
	// "on-failure" (restart on non-zero exit code, with an optional max
	// retry count), and "always" (always restart on container stop, unless
	// explicitly requested by API).
	// Note that this is NOT actually a name of any sort - the poor naming
	// is for Docker compatibility.
	Name string `json:"Name,omitempty"`
}

// Validate validates this libpod get container o k body host config restart policy
func (o *LibpodGetContainerOKBodyHostConfigRestartPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigRestartPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigRestartPolicy) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigRestartPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyHostConfigUlimitsItems0 InspectUlimit is a ulimit that will be applied to the container.
swagger:model LibpodGetContainerOKBodyHostConfigUlimitsItems0
*/
type LibpodGetContainerOKBodyHostConfigUlimitsItems0 struct {

	// Hard is the hard limit that will be applied.
	Hard uint64 `json:"Hard,omitempty"`

	// Name is the name (type) of the ulimit.
	Name string `json:"Name,omitempty"`

	// Soft is the soft limit that will be applied.
	Soft uint64 `json:"Soft,omitempty"`
}

// Validate validates this libpod get container o k body host config ulimits items0
func (o *LibpodGetContainerOKBodyHostConfigUlimitsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigUlimitsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyHostConfigUlimitsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyHostConfigUlimitsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyMountsItems0 InspectMount provides a record of a single mount in a container. It contains
// fields for both named and normal volumes. Only user-specified volumes will be
// included, and tmpfs volumes are not included even if the user specified them.
swagger:model LibpodGetContainerOKBodyMountsItems0
*/
type LibpodGetContainerOKBodyMountsItems0 struct {

	// The destination directory for the volume. Specified as a path within
	// the container, as it would be passed into the OCI runtime.
	Destination string `json:"Destination,omitempty"`

	// The driver used for the named volume. Empty for bind mounts.
	Driver string `json:"Driver,omitempty"`

	// Contains SELinux :z/:Z mount options. Unclear what, if anything, else
	// goes in here.
	Mode string `json:"Mode,omitempty"`

	// The name of the volume. Empty for bind mounts.
	Name string `json:"Name,omitempty"`

	// All remaining mount options. Additional data, not present in the
	// original output.
	Options []string `json:"Options"`

	// Mount propagation for the mount. Can be empty if not specified, but
	// is always printed - no omitempty.
	Propagation string `json:"Propagation,omitempty"`

	// Whether the volume is read-write
	RW bool `json:"RW,omitempty"`

	// The source directory for the volume.
	Source string `json:"Source,omitempty"`

	// Whether the mount is a volume or bind mount. Allowed values are
	// "volume" and "bind".
	Type string `json:"Type,omitempty"`
}

// Validate validates this libpod get container o k body mounts items0
func (o *LibpodGetContainerOKBodyMountsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyMountsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyMountsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyMountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyNetworkSettings InspectNetworkSettings holds information about the network settings of the
// container.
// Many fields are maintained only for compatibility with `docker inspect` and
// are unused within Libpod.
swagger:model LibpodGetContainerOKBodyNetworkSettings
*/
type LibpodGetContainerOKBodyNetworkSettings struct {

	// AdditionalMacAddresses is a set of additional MAC Addresses beyond
	// the first. CNI may configure more than one interface for a single
	// network, which can cause this.
	AdditionalMacAddresses []string `json:"AdditionalMACAddresses"`

	// bridge
	Bridge string `json:"Bridge,omitempty"`

	// EndpointID is unused, maintained exclusively for compatibility.
	EndpointID string `json:"EndpointID,omitempty"`

	// Gateway is the IP address of the gateway this network will use.
	Gateway string `json:"Gateway,omitempty"`

	// GlobalIPv6Address is the global-scope IPv6 Address for this network.
	GlobalIPV6Address string `json:"GlobalIPv6Address,omitempty"`

	// GlobalIPv6PrefixLen is the length of the subnet mask of this network.
	GlobalIPV6PrefixLen int64 `json:"GlobalIPv6PrefixLen,omitempty"`

	// hairpin mode
	HairpinMode bool `json:"HairpinMode,omitempty"`

	// IPAddress is the IP address for this network.
	IPAddress string `json:"IPAddress,omitempty"`

	// IPPrefixLen is the length of the subnet mask of this network.
	IPPrefixLen int64 `json:"IPPrefixLen,omitempty"`

	// IPv6Gateway is the IPv6 gateway this network will use.
	IPV6Gateway string `json:"IPv6Gateway,omitempty"`

	// link local IPv6 address
	LinkLocalIPV6Address string `json:"LinkLocalIPv6Address,omitempty"`

	// link local IPv6 prefix len
	LinkLocalIPV6PrefixLen int64 `json:"LinkLocalIPv6PrefixLen,omitempty"`

	// MacAddress is the MAC address for the interface in this network.
	MacAddress string `json:"MacAddress,omitempty"`

	// Networks contains information on non-default CNI networks this
	// container has joined.
	// It is a map of network name to network information.
	Networks map[string]LibpodGetContainerOKBodyNetworkSettingsNetworksAnon `json:"Networks,omitempty"`

	// ports
	Ports map[string][]LibpodGetContainerOKBodyNetworkSettingsPortsItems0 `json:"Ports,omitempty"`

	// sandbox ID
	SandboxID string `json:"SandboxID,omitempty"`

	// sandbox key
	SandboxKey string `json:"SandboxKey,omitempty"`

	// SecondaryIPAddresses is a list of extra IP Addresses that the
	// container has been assigned in this network.
	SecondaryIPAddresses []string `json:"SecondaryIPAddresses"`

	// SecondaryIPv6Addresses is a list of extra IPv6 Addresses that the
	// container has been assigned in this networ.
	SecondaryIPV6Addresses []string `json:"SecondaryIPv6Addresses"`
}

// Validate validates this libpod get container o k body network settings
func (o *LibpodGetContainerOKBodyNetworkSettings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNetworks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodGetContainerOKBodyNetworkSettings) validateNetworks(formats strfmt.Registry) error {

	if swag.IsZero(o.Networks) { // not required
		return nil
	}

	for k := range o.Networks {

		if swag.IsZero(o.Networks[k]) { // not required
			continue
		}
		if val, ok := o.Networks[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodGetContainerOKBodyNetworkSettings) validatePorts(formats strfmt.Registry) error {

	if swag.IsZero(o.Ports) { // not required
		return nil
	}

	for k := range o.Ports {

		if err := validate.Required("libpodGetContainerOK"+"."+"NetworkSettings"+"."+"Ports"+"."+k, "body", o.Ports[k]); err != nil {
			return err
		}

		for i := 0; i < len(o.Ports[k]); i++ {

			if err := o.Ports[k][i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "NetworkSettings" + "." + "Ports" + "." + k + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyNetworkSettings) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyNetworkSettings) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyNetworkSettings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyNetworkSettingsNetworksAnon InspectAdditionalNetwork holds information about non-default CNI networks the
// container has been connected to.
// As with InspectNetworkSettings, many fields are unused and maintained only
// for compatibility with Docker.
swagger:model LibpodGetContainerOKBodyNetworkSettingsNetworksAnon
*/
type LibpodGetContainerOKBodyNetworkSettingsNetworksAnon struct {

	// AdditionalMacAddresses is a set of additional MAC Addresses beyond
	// the first. CNI may configure more than one interface for a single
	// network, which can cause this.
	AdditionalMacAddresses []string `json:"AdditionalMACAddresses"`

	// DriverOpts is presently unused and maintained exclusively for
	// compatibility.
	DriverOpts map[string]string `json:"DriverOpts,omitempty"`

	// EndpointID is unused, maintained exclusively for compatibility.
	EndpointID string `json:"EndpointID,omitempty"`

	// Gateway is the IP address of the gateway this network will use.
	Gateway string `json:"Gateway,omitempty"`

	// GlobalIPv6Address is the global-scope IPv6 Address for this network.
	GlobalIPV6Address string `json:"GlobalIPv6Address,omitempty"`

	// GlobalIPv6PrefixLen is the length of the subnet mask of this network.
	GlobalIPV6PrefixLen int64 `json:"GlobalIPv6PrefixLen,omitempty"`

	// IPAMConfig is presently unused and maintained exclusively for
	// compatibility.
	IPAMConfig map[string]string `json:"IPAMConfig,omitempty"`

	// IPAddress is the IP address for this network.
	IPAddress string `json:"IPAddress,omitempty"`

	// IPPrefixLen is the length of the subnet mask of this network.
	IPPrefixLen int64 `json:"IPPrefixLen,omitempty"`

	// IPv6Gateway is the IPv6 gateway this network will use.
	IPV6Gateway string `json:"IPv6Gateway,omitempty"`

	// Links is presently unused and maintained exclusively for
	// compatibility.
	Links []string `json:"Links"`

	// MacAddress is the MAC address for the interface in this network.
	MacAddress string `json:"MacAddress,omitempty"`

	// Name of the network we're connecting to.
	NetworkID string `json:"NetworkID,omitempty"`

	// SecondaryIPAddresses is a list of extra IP Addresses that the
	// container has been assigned in this network.
	SecondaryIPAddresses []string `json:"SecondaryIPAddresses"`

	// SecondaryIPv6Addresses is a list of extra IPv6 Addresses that the
	// container has been assigned in this networ.
	SecondaryIPV6Addresses []string `json:"SecondaryIPv6Addresses"`
}

// Validate validates this libpod get container o k body network settings networks anon
func (o *LibpodGetContainerOKBodyNetworkSettingsNetworksAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyNetworkSettingsNetworksAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyNetworkSettingsNetworksAnon) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyNetworkSettingsNetworksAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyNetworkSettingsPortsItems0 InspectHostPort provides information on a port on the host that a container's
// port is bound to.
swagger:model LibpodGetContainerOKBodyNetworkSettingsPortsItems0
*/
type LibpodGetContainerOKBodyNetworkSettingsPortsItems0 struct {

	// IP on the host we are bound to. "" if not specified (binding to all
	// IPs).
	HostIP string `json:"HostIp,omitempty"`

	// Port on the host we are bound to. No special formatting - just an
	// integer stuffed into a string.
	HostPort string `json:"HostPort,omitempty"`
}

// Validate validates this libpod get container o k body network settings ports items0
func (o *LibpodGetContainerOKBodyNetworkSettingsPortsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyNetworkSettingsPortsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyNetworkSettingsPortsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyNetworkSettingsPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyState InspectContainerState provides a detailed record of a container's current
// state. It is returned as part of InspectContainerData.
// As with InspectContainerData, many portions of this struct are matched to
// Docker, but here we see more fields that are unused (nonsensical in the
// context of Libpod).
swagger:model LibpodGetContainerOKBodyState
*/
type LibpodGetContainerOKBodyState struct {

	// conmon pid
	ConmonPid int64 `json:"ConmonPid,omitempty"`

	// dead
	Dead bool `json:"Dead,omitempty"`

	// error
	Error string `json:"Error,omitempty"`

	// exit code
	ExitCode int32 `json:"ExitCode,omitempty"`

	// finished at
	// Format: date-time
	FinishedAt strfmt.DateTime `json:"FinishedAt,omitempty"`

	// o o m killed
	OOMKilled bool `json:"OOMKilled,omitempty"`

	// oci version
	OciVersion string `json:"OciVersion,omitempty"`

	// paused
	Paused bool `json:"Paused,omitempty"`

	// pid
	Pid int64 `json:"Pid,omitempty"`

	// restarting
	Restarting bool `json:"Restarting,omitempty"`

	// running
	Running bool `json:"Running,omitempty"`

	// started at
	// Format: date-time
	StartedAt strfmt.DateTime `json:"StartedAt,omitempty"`

	// status
	Status string `json:"Status,omitempty"`

	// healthcheck
	Healthcheck *LibpodGetContainerOKBodyStateHealthcheck `json:"Healthcheck,omitempty"`
}

// Validate validates this libpod get container o k body state
func (o *LibpodGetContainerOKBodyState) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFinishedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHealthcheck(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodGetContainerOKBodyState) validateFinishedAt(formats strfmt.Registry) error {

	if swag.IsZero(o.FinishedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("libpodGetContainerOK"+"."+"State"+"."+"FinishedAt", "body", "date-time", o.FinishedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *LibpodGetContainerOKBodyState) validateStartedAt(formats strfmt.Registry) error {

	if swag.IsZero(o.StartedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("libpodGetContainerOK"+"."+"State"+"."+"StartedAt", "body", "date-time", o.StartedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *LibpodGetContainerOKBodyState) validateHealthcheck(formats strfmt.Registry) error {

	if swag.IsZero(o.Healthcheck) { // not required
		return nil
	}

	if o.Healthcheck != nil {
		if err := o.Healthcheck.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libpodGetContainerOK" + "." + "State" + "." + "Healthcheck")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyState) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyState) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyState
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyStateHealthcheck HealthCheckResults describes the results/logs from a healthcheck
swagger:model LibpodGetContainerOKBodyStateHealthcheck
*/
type LibpodGetContainerOKBodyStateHealthcheck struct {

	// FailingStreak is the number of consecutive failed healthchecks
	FailingStreak int64 `json:"FailingStreak,omitempty"`

	// Log describes healthcheck attempts and results
	Log []*LibpodGetContainerOKBodyStateHealthcheckLogItems0 `json:"Log"`

	// Status healthy or unhealthy
	Status string `json:"Status,omitempty"`
}

// Validate validates this libpod get container o k body state healthcheck
func (o *LibpodGetContainerOKBodyStateHealthcheck) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodGetContainerOKBodyStateHealthcheck) validateLog(formats strfmt.Registry) error {

	if swag.IsZero(o.Log) { // not required
		return nil
	}

	for i := 0; i < len(o.Log); i++ {
		if swag.IsZero(o.Log[i]) { // not required
			continue
		}

		if o.Log[i] != nil {
			if err := o.Log[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libpodGetContainerOK" + "." + "State" + "." + "Healthcheck" + "." + "Log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyStateHealthcheck) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyStateHealthcheck) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyStateHealthcheck
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodGetContainerOKBodyStateHealthcheckLogItems0 HealthCheckLog describes the results of a single healthcheck
swagger:model LibpodGetContainerOKBodyStateHealthcheckLogItems0
*/
type LibpodGetContainerOKBodyStateHealthcheckLogItems0 struct {

	// End time as a string
	End string `json:"End,omitempty"`

	// Exitcode is 0 or 1
	ExitCode int64 `json:"ExitCode,omitempty"`

	// Output is the stdout/stderr from the healthcheck command
	Output string `json:"Output,omitempty"`

	// Start time as string
	Start string `json:"Start,omitempty"`
}

// Validate validates this libpod get container o k body state healthcheck log items0
func (o *LibpodGetContainerOKBodyStateHealthcheckLogItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyStateHealthcheckLogItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodGetContainerOKBodyStateHealthcheckLogItems0) UnmarshalBinary(b []byte) error {
	var res LibpodGetContainerOKBodyStateHealthcheckLogItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
