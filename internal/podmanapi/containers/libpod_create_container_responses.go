// Code generated by go-swagger; DO NOT EDIT.

package containers

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// LibpodCreateContainerReader is a Reader for the LibpodCreateContainer structure.
type LibpodCreateContainerReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *LibpodCreateContainerReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewLibpodCreateContainerCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewLibpodCreateContainerBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewLibpodCreateContainerNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 409:
		result := NewLibpodCreateContainerConflict()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewLibpodCreateContainerInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewLibpodCreateContainerCreated creates a LibpodCreateContainerCreated with default headers values
func NewLibpodCreateContainerCreated() *LibpodCreateContainerCreated {
	return &LibpodCreateContainerCreated{}
}

/* LibpodCreateContainerCreated describes a response with status code 201, with default header values.

Create container
*/
type LibpodCreateContainerCreated struct {
	Payload *LibpodCreateContainerCreatedBody
}

func (o *LibpodCreateContainerCreated) Error() string {
	return fmt.Sprintf("[POST /libpod/containers/create][%d] libpodCreateContainerCreated  %+v", 201, o.Payload)
}
func (o *LibpodCreateContainerCreated) GetPayload() *LibpodCreateContainerCreatedBody {
	return o.Payload
}

func (o *LibpodCreateContainerCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(LibpodCreateContainerCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewLibpodCreateContainerBadRequest creates a LibpodCreateContainerBadRequest with default headers values
func NewLibpodCreateContainerBadRequest() *LibpodCreateContainerBadRequest {
	return &LibpodCreateContainerBadRequest{}
}

/* LibpodCreateContainerBadRequest describes a response with status code 400, with default header values.

Bad parameter in request
*/
type LibpodCreateContainerBadRequest struct {
	Payload *LibpodCreateContainerBadRequestBody
}

func (o *LibpodCreateContainerBadRequest) Error() string {
	return fmt.Sprintf("[POST /libpod/containers/create][%d] libpodCreateContainerBadRequest  %+v", 400, o.Payload)
}
func (o *LibpodCreateContainerBadRequest) GetPayload() *LibpodCreateContainerBadRequestBody {
	return o.Payload
}

func (o *LibpodCreateContainerBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(LibpodCreateContainerBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewLibpodCreateContainerNotFound creates a LibpodCreateContainerNotFound with default headers values
func NewLibpodCreateContainerNotFound() *LibpodCreateContainerNotFound {
	return &LibpodCreateContainerNotFound{}
}

/* LibpodCreateContainerNotFound describes a response with status code 404, with default header values.

No such container
*/
type LibpodCreateContainerNotFound struct {
	Payload *LibpodCreateContainerNotFoundBody
}

func (o *LibpodCreateContainerNotFound) Error() string {
	return fmt.Sprintf("[POST /libpod/containers/create][%d] libpodCreateContainerNotFound  %+v", 404, o.Payload)
}
func (o *LibpodCreateContainerNotFound) GetPayload() *LibpodCreateContainerNotFoundBody {
	return o.Payload
}

func (o *LibpodCreateContainerNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(LibpodCreateContainerNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewLibpodCreateContainerConflict creates a LibpodCreateContainerConflict with default headers values
func NewLibpodCreateContainerConflict() *LibpodCreateContainerConflict {
	return &LibpodCreateContainerConflict{}
}

/* LibpodCreateContainerConflict describes a response with status code 409, with default header values.

Conflict error in operation
*/
type LibpodCreateContainerConflict struct {
	Payload *LibpodCreateContainerConflictBody
}

func (o *LibpodCreateContainerConflict) Error() string {
	return fmt.Sprintf("[POST /libpod/containers/create][%d] libpodCreateContainerConflict  %+v", 409, o.Payload)
}
func (o *LibpodCreateContainerConflict) GetPayload() *LibpodCreateContainerConflictBody {
	return o.Payload
}

func (o *LibpodCreateContainerConflict) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(LibpodCreateContainerConflictBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewLibpodCreateContainerInternalServerError creates a LibpodCreateContainerInternalServerError with default headers values
func NewLibpodCreateContainerInternalServerError() *LibpodCreateContainerInternalServerError {
	return &LibpodCreateContainerInternalServerError{}
}

/* LibpodCreateContainerInternalServerError describes a response with status code 500, with default header values.

Internal server error
*/
type LibpodCreateContainerInternalServerError struct {
	Payload *LibpodCreateContainerInternalServerErrorBody
}

func (o *LibpodCreateContainerInternalServerError) Error() string {
	return fmt.Sprintf("[POST /libpod/containers/create][%d] libpodCreateContainerInternalServerError  %+v", 500, o.Payload)
}
func (o *LibpodCreateContainerInternalServerError) GetPayload() *LibpodCreateContainerInternalServerErrorBody {
	return o.Payload
}

func (o *LibpodCreateContainerInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(LibpodCreateContainerInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*LibpodCreateContainerBadRequestBody libpod create container bad request body
swagger:model LibpodCreateContainerBadRequestBody
*/
type LibpodCreateContainerBadRequestBody struct {

	// API root cause formatted for automated parsing
	// Example: API root cause
	Because string `json:"cause,omitempty"`

	// human error message, formatted for a human to read
	// Example: human error message
	Message string `json:"message,omitempty"`

	// http response code
	ResponseCode int64 `json:"response,omitempty"`
}

// Validate validates this libpod create container bad request body
func (o *LibpodCreateContainerBadRequestBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container bad request body based on context it is used
func (o *LibpodCreateContainerBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerBadRequestBody) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerBody SpecGenerator creates an OCI spec and Libpod configuration options to create
// a container based on the given configuration.
swagger:model LibpodCreateContainerBody
*/
type LibpodCreateContainerBody struct {

	// Annotations are key-value options passed into the container runtime
	// that can be used to trigger special behavior.
	// Optional.
	Annotations map[string]string `json:"annotations,omitempty"`

	// ApparmorProfile is the name of the Apparmor profile the container
	// will use.
	// Optional.
	ApparmorProfile string `json:"apparmor_profile,omitempty"`

	// CapAdd are capabilities which will be added to the container.
	// Conflicts with Privileged.
	// Optional.
	CapAdd []string `json:"cap_add"`

	// CapDrop are capabilities which will be removed from the container.
	// Conflicts with Privileged.
	// Optional.
	CapDrop []string `json:"cap_drop"`

	// CgroupParent is the container's CGroup parent.
	// If not set, the default for the current cgroup driver will be used.
	// Optional.
	CgroupParent string `json:"cgroup_parent,omitempty"`

	// CgroupsMode sets a policy for how cgroups will be created in the
	// container, including the ability to disable creation entirely.
	CgroupsMode string `json:"cgroups_mode,omitempty"`

	// CNINetworks is a list of CNI networks to join the container to.
	// If this list is empty, the default CNI network will be joined
	// instead. If at least one entry is present, we will not join the
	// default network (unless it is part of this list).
	// Only available if NetNS is set to bridge.
	// Optional.
	CNINetworks []string `json:"cni_networks"`

	// Command is the container's command.
	// If not given and Image is specified, this will be populated by the
	// image's configuration.
	// Optional.
	Command []string `json:"command"`

	// ConmonPidFile is a path at which a PID file for Conmon will be
	// placed.
	// If not given, a default location will be used.
	// Optional.
	ConmonPidFile string `json:"conmon_pid_file,omitempty"`

	// ContainerCreateCommand is the command that was used to create this
	// container.
	// This will be shown in the output of Inspect() on the container, and
	// may also be used by some tools that wish to recreate the container
	// (e.g. `podman generate systemd --new`).
	// Optional.
	ContainerCreateCommand []string `json:"containerCreateCommand"`

	// Devices are devices that will be added to the container.
	// Optional.
	Devices []*LibpodCreateContainerParamsBodyDevicesItems0 `json:"devices"`

	// DNSOptions is a set of DNS options that will be used in the
	// container's resolv.conf, replacing the host's DNS options which are
	// used by default.
	// Conflicts with UseImageResolvConf.
	// Optional.
	DNSOptions []string `json:"dns_option"`

	// DNSSearch is a set of DNS search domains that will be used in the
	// container's resolv.conf, replacing the host's DNS search domains
	// which are used by default.
	// Conflicts with UseImageResolvConf.
	// Optional.
	DNSSearch []string `json:"dns_search"`

	// DNSServers is a set of DNS servers that will be used in the
	// container's resolv.conf, replacing the host's DNS Servers which are
	// used by default.
	// Conflicts with UseImageResolvConf.
	// Optional.
	DNSServers []string `json:"dns_server"`

	// Entrypoint is the container's entrypoint.
	// If not given and Image is specified, this will be populated by the
	// image's configuration.
	// Optional.
	Entrypoint []string `json:"entrypoint"`

	// Env is a set of environment variables that will be set in the
	// container.
	// Optional.
	Env map[string]string `json:"env,omitempty"`

	// EnvHost indicates that the host environment should be added to container
	// Optional.
	EnvHost bool `json:"env_host,omitempty"`

	// Expose is a number of ports that will be forwarded to the container
	// if PublishExposedPorts is set.
	// Expose is a map of uint16 (port number) to a string representing
	// protocol. Allowed protocols are "tcp", "udp", and "sctp", or some
	// combination of the three separated by commas.
	// If protocol is set to "" we will assume TCP.
	// Only available if NetNS is set to Bridge or Slirp, and
	// PublishExposedPorts is set.
	// Optional.
	Expose interface{} `json:"expose,omitempty"`

	// Groups are a list of supplemental groups the container's user will
	// be granted access to.
	// Optional.
	Groups []string `json:"groups"`

	// HostAdd is a set of hosts which will be added to the container's
	// etc/hosts file.
	// Conflicts with UseImageHosts.
	// Optional.
	HostAdd []string `json:"hostadd"`

	// Hostname is the container's hostname. If not set, the hostname will
	// not be modified (if UtsNS is not private) or will be set to the
	// container ID (if UtsNS is private).
	// Conflicts with UtsNS if UtsNS is not set to private.
	// Optional.
	Hostname string `json:"hostname,omitempty"`

	// EnvHTTPProxy indicates that the http host proxy environment variables
	// should be added to container
	// Optional.
	HTTPProxy bool `json:"httpproxy,omitempty"`

	// Image is the image the container will be based on. The image will be
	// used as the container's root filesystem, and its environment vars,
	// volumes, and other configuration will be applied to the container.
	// Conflicts with Rootfs.
	// At least one of Image or Rootfs must be specified.
	Image string `json:"image,omitempty"`

	// ImageVolumeMode indicates how image volumes will be created.
	// Supported modes are "ignore" (do not create), "tmpfs" (create as
	// tmpfs), and "anonymous" (create as anonymous volumes).
	// The default if unset is anonymous.
	// Optional.
	ImageVolumeMode string `json:"image_volume_mode,omitempty"`

	// Init specifies that an init binary will be mounted into the
	// container, and will be used as PID1.
	Init bool `json:"init,omitempty"`

	// InitPath specifies the path to the init binary that will be added if
	// Init is specified above. If not specified, the default set in the
	// Libpod config will be used. Ignored if Init above is not set.
	// Optional.
	InitPath string `json:"init_path,omitempty"`

	// Labels are key-value pairs that are used to add metadata to
	// containers.
	// Optional.
	Labels map[string]string `json:"labels,omitempty"`

	// Mounts are mounts that will be added to the container.
	// These will supersede Image Volumes and VolumesFrom volumes where
	// there are conflicts.
	// Optional.
	Mounts []*LibpodCreateContainerParamsBodyMountsItems0 `json:"mounts"`

	// Name is the name the container will be given.
	// If no name is provided, one will be randomly generated.
	// Optional.
	Name string `json:"name,omitempty"`

	// Namespace is the libpod namespace the container will be placed in.
	// Optional.
	Namespace string `json:"namespace,omitempty"`

	// NetworkOptions are additional options for each network
	// Optional.
	NetworkOptions map[string][]string `json:"network_options,omitempty"`

	// NoNewPrivileges is whether the container will set the no new
	// privileges flag on create, which disables gaining additional
	// privileges (e.g. via setuid) in the container.
	NoNewPrivileges bool `json:"no_new_privileges,omitempty"`

	// OCIRuntime is the name of the OCI runtime that will be used to create
	// the container.
	// If not specified, the default will be used.
	// Optional.
	OCIRuntime string `json:"oci_runtime,omitempty"`

	// OOMScoreAdj adjusts the score used by the OOM killer to determine
	// processes to kill for the container's process.
	// Optional.
	OOMScoreAdj int64 `json:"oom_score_adj,omitempty"`

	// Overlay volumes are named volumes that will be added to the container.
	// Optional.
	OverlayVolumes []*LibpodCreateContainerParamsBodyOverlayVolumesItems0 `json:"overlay_volumes"`

	// Pod is the ID of the pod the container will join.
	// Optional.
	Pod string `json:"pod,omitempty"`

	// PortBindings is a set of ports to map into the container.
	// Only available if NetNS is set to bridge or slirp.
	// Optional.
	PortMappings []*LibpodCreateContainerParamsBodyPortmappingsItems0 `json:"portmappings"`

	// Privileged is whether the container is privileged.
	// Privileged does the following:
	// Adds all devices on the system to the container.
	// Adds all capabilities to the container.
	// Disables Seccomp, SELinux, and Apparmor confinement.
	// (Though SELinux can be manually re-enabled).
	// TODO: this conflicts with things.
	// TODO: this does more.
	Privileged bool `json:"privileged,omitempty"`

	// ProcOpts are the options used for the proc mount.
	ProcOpts []string `json:"procfs_opts"`

	// PublishExposedPorts will publish ports specified in the image to
	// random unused ports (guaranteed to be above 1024) on the host.
	// This is based on ports set in Expose below, and any ports specified
	// by the Image (if one is given).
	// Only available if NetNS is set to Bridge or Slirp.
	PublishExposedPorts bool `json:"publish_image_ports,omitempty"`

	// Rlimits are POSIX rlimits to apply to the container.
	// Optional.
	Rlimits []*LibpodCreateContainerParamsBodyRLimitsItems0 `json:"r_limits"`

	// ReadOnlyFilesystem indicates that everything will be mounted
	// as read-only
	ReadOnlyFilesystem bool `json:"read_only_filesystem,omitempty"`

	// Remove indicates if the container should be removed once it has been started
	// and exits
	Remove bool `json:"remove,omitempty"`

	// RestartPolicy is the container's restart policy - an action which
	// will be taken when the container exits.
	// If not given, the default policy, which does nothing, will be used.
	// Optional.
	RestartPolicy string `json:"restart_policy,omitempty"`

	// RestartRetries is the number of attempts that will be made to restart
	// the container.
	// Only available when RestartPolicy is set to "on-failure".
	// Optional.
	RestartRetries uint64 `json:"restart_tries,omitempty"`

	// Rootfs is the path to a directory that will be used as the
	// container's root filesystem. No modification will be made to the
	// directory, it will be directly mounted into the container as root.
	// Conflicts with Image.
	// At least one of Image or Rootfs must be specified.
	Rootfs string `json:"rootfs,omitempty"`

	// RootfsPropagation is the rootfs propagation mode for the container.
	// If not set, the default of rslave will be used.
	// Optional.
	RootfsPropagation string `json:"rootfs_propagation,omitempty"`

	// Determine how to handle the NOTIFY_SOCKET - do we participate or pass it through
	// "container" - let the OCI runtime deal with it, advertise conmon's MAINPID
	// "conmon-only" - advertise conmon's MAINPID, send READY when started, don't pass to OCI
	// "ignore" - unset NOTIFY_SOCKET
	SdNotifyMode string `json:"sdnotifyMode,omitempty"`

	// SeccompPolicy determines which seccomp profile gets applied
	// the container. valid values: empty,default,image
	SeccompPolicy string `json:"seccomp_policy,omitempty"`

	// SeccompProfilePath is the path to a JSON file containing the
	// container's Seccomp profile.
	// If not specified, no Seccomp profile will be used.
	// Optional.
	SeccompProfilePath string `json:"seccomp_profile_path,omitempty"`

	// SelinuxProcessLabel is the process label the container will use.
	// If SELinux is enabled and this is not specified, a label will be
	// automatically generated if not specified.
	// Optional.
	SelinuxOpts []string `json:"selinux_opts"`

	// ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes.
	// Conflicts with ShmSize if IpcNS is not private.
	// Optional.
	ShmSize int64 `json:"shm_size,omitempty"`

	// Stdin is whether the container will keep its STDIN open.
	Stdin bool `json:"stdin,omitempty"`

	// StopTimeout is a timeout between the container's stop signal being
	// sent and SIGKILL being sent.
	// If not provided, the default will be used.
	// If 0 is used, stop signal will not be sent, and SIGKILL will be sent
	// instead.
	// Optional.
	StopTimeout *uint64 `json:"stop_timeout,omitempty"`

	// Sysctl sets kernel parameters for the container
	Sysctl map[string]string `json:"sysctl,omitempty"`

	// Systemd is whether the container will be started in systemd mode.
	// Valid options are "true", "false", and "always".
	// "true" enables this mode only if the binary run in the container is
	// sbin/init or systemd. "always" unconditionally enables systemd mode.
	// "false" unconditionally disables systemd mode.
	// If enabled, mounts and stop signal will be modified.
	// If set to "always" or set to "true" and conditionally triggered,
	// conflicts with StopSignal.
	// If not specified, "false" will be assumed.
	// Optional.
	Systemd string `json:"systemd,omitempty"`

	// Terminal is whether the container will create a PTY.
	// Optional.
	Terminal bool `json:"terminal,omitempty"`

	// IO read rate limit per cgroup per device, bytes per second
	ThrottleReadBpsDevice map[string]LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon `json:"throttleReadBpsDevice,omitempty"`

	// IO read rate limit per cgroup per device, IO per second
	ThrottleReadIOPSDevice map[string]LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon `json:"throttleReadIOPSDevice,omitempty"`

	// IO write rate limit per cgroup per device, bytes per second
	ThrottleWriteBpsDevice map[string]LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon `json:"throttleWriteBpsDevice,omitempty"`

	// IO write rate limit per cgroup per device, IO per second
	ThrottleWriteIOPSDevice map[string]LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon `json:"throttleWriteIOPSDevice,omitempty"`

	// Timezone is the timezone inside the container.
	// Local means it has the same timezone as the host machine
	Timezone string `json:"timezone,omitempty"`

	// Umask is the umask the init process of the container will be run with.
	Umask string `json:"umask,omitempty"`

	// CgroupConf are key-value options passed into the container runtime
	// that are used to configure cgroup v2.
	// Optional.
	CgroupConf map[string]string `json:"unified,omitempty"`

	// UseImageHosts indicates that /etc/hosts should not be managed by
	// Podman, and instead sourced from the image.
	// Conflicts with HostAdd.
	UseImageHosts bool `json:"use_image_hosts,omitempty"`

	// UseImageResolvConf indicates that resolv.conf should not be managed
	// by Podman, but instead sourced from the image.
	// Conflicts with DNSServer, DNSSearch, DNSOption.
	UseImageResolvConf bool `json:"use_image_resolve_conf,omitempty"`

	// User is the user the container will be run as.
	// Can be given as a UID or a username; if a username, it will be
	// resolved within the container, using the container's /etc/passwd.
	// If unset, the container will be run as root.
	// Optional.
	User string `json:"user,omitempty"`

	// Volumes are named volumes that will be added to the container.
	// These will supersede Image Volumes and VolumesFrom volumes where
	// there are conflicts.
	// Optional.
	Volumes []*LibpodCreateContainerParamsBodyVolumesItems0 `json:"volumes"`

	// VolumesFrom is a set of containers whose volumes will be added to
	// this container. The name or ID of the container must be provided, and
	// may optionally be followed by a : and then one or more
	// comma-separated options. Valid options are 'ro', 'rw', and 'z'.
	// Options will be used for all volumes sourced from the container.
	VolumesFrom []string `json:"volumes_from"`

	// Weight per cgroup per device, can override BlkioWeight
	WeightDevice map[string]LibpodCreateContainerParamsBodyWeightDeviceAnon `json:"weightDevice,omitempty"`

	// WorkDir is the container's working directory.
	// If unset, the default, /, will be used.
	// Optional.
	WorkDir string `json:"work_dir,omitempty"`

	// cgroupns
	Cgroupns *LibpodCreateContainerParamsBodyCgroupns `json:"cgroupns,omitempty"`

	// healthconfig
	Healthconfig *LibpodCreateContainerParamsBodyHealthconfig `json:"healthconfig,omitempty"`

	// idmappings
	Idmappings *LibpodCreateContainerParamsBodyIdmappings `json:"idmappings,omitempty"`

	// ipcns
	Ipcns *LibpodCreateContainerParamsBodyIpcns `json:"ipcns,omitempty"`

	// log configuration
	LogConfiguration *LibpodCreateContainerParamsBodyLogConfiguration `json:"log_configuration,omitempty"`

	// netns
	Netns *LibpodCreateContainerParamsBodyNetns `json:"netns,omitempty"`

	// pidns
	Pidns *LibpodCreateContainerParamsBodyPidns `json:"pidns,omitempty"`

	// resource limits
	ResourceLimits *LibpodCreateContainerParamsBodyResourceLimits `json:"resource_limits,omitempty"`

	// An IP is a single IP address, a slice of bytes.
	// Functions in this package accept either 4-byte (IPv4)
	// or 16-byte (IPv6) slices as input.
	//
	// Note that in this documentation, referring to an
	// IP address as an IPv4 address or an IPv6 address
	// is a semantic property of the address, not just the
	// length of the byte slice: a 16-byte slice can still
	// be an IPv4 address.
	StaticIP string `json:"static_ip,omitempty"`

	// An IP is a single IP address, a slice of bytes.
	// Functions in this package accept either 4-byte (IPv4)
	// or 16-byte (IPv6) slices as input.
	//
	// Note that in this documentation, referring to an
	// IP address as an IPv4 address or an IPv6 address
	// is a semantic property of the address, not just the
	// length of the byte slice: a 16-byte slice can still
	// be an IPv4 address.
	StaticIPV6 string `json:"static_ipv6,omitempty"`

	// A HardwareAddr represents a physical hardware address.
	StaticMac []uint8 `json:"static_mac"`

	// A Signal is a number describing a process signal.
	//
	// It implements the os.Signal interface.
	StopSignal int64 `json:"stop_signal,omitempty"`

	// userns
	Userns *LibpodCreateContainerParamsBodyUserns `json:"userns,omitempty"`

	// utsns
	Utsns *LibpodCreateContainerParamsBodyUtsns `json:"utsns,omitempty"`
}

// Validate validates this libpod create container body
func (o *LibpodCreateContainerBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDevices(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMounts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOverlayVolumes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePortMappings(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRlimits(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThrottleReadBpsDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThrottleReadIOPSDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThrottleWriteBpsDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThrottleWriteIOPSDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCgroupns(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHealthconfig(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIdmappings(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIpcns(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLogConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetns(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePidns(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResourceLimits(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserns(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUtsns(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerBody) validateDevices(formats strfmt.Registry) error {
	if swag.IsZero(o.Devices) { // not required
		return nil
	}

	for i := 0; i < len(o.Devices); i++ {
		if swag.IsZero(o.Devices[i]) { // not required
			continue
		}

		if o.Devices[i] != nil {
			if err := o.Devices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateMounts(formats strfmt.Registry) error {
	if swag.IsZero(o.Mounts) { // not required
		return nil
	}

	for i := 0; i < len(o.Mounts); i++ {
		if swag.IsZero(o.Mounts[i]) { // not required
			continue
		}

		if o.Mounts[i] != nil {
			if err := o.Mounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "mounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateOverlayVolumes(formats strfmt.Registry) error {
	if swag.IsZero(o.OverlayVolumes) { // not required
		return nil
	}

	for i := 0; i < len(o.OverlayVolumes); i++ {
		if swag.IsZero(o.OverlayVolumes[i]) { // not required
			continue
		}

		if o.OverlayVolumes[i] != nil {
			if err := o.OverlayVolumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "overlay_volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validatePortMappings(formats strfmt.Registry) error {
	if swag.IsZero(o.PortMappings) { // not required
		return nil
	}

	for i := 0; i < len(o.PortMappings); i++ {
		if swag.IsZero(o.PortMappings[i]) { // not required
			continue
		}

		if o.PortMappings[i] != nil {
			if err := o.PortMappings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "portmappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateRlimits(formats strfmt.Registry) error {
	if swag.IsZero(o.Rlimits) { // not required
		return nil
	}

	for i := 0; i < len(o.Rlimits); i++ {
		if swag.IsZero(o.Rlimits[i]) { // not required
			continue
		}

		if o.Rlimits[i] != nil {
			if err := o.Rlimits[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "r_limits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateThrottleReadBpsDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.ThrottleReadBpsDevice) { // not required
		return nil
	}

	for k := range o.ThrottleReadBpsDevice {

		if swag.IsZero(o.ThrottleReadBpsDevice[k]) { // not required
			continue
		}
		if val, ok := o.ThrottleReadBpsDevice[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateThrottleReadIOPSDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.ThrottleReadIOPSDevice) { // not required
		return nil
	}

	for k := range o.ThrottleReadIOPSDevice {

		if swag.IsZero(o.ThrottleReadIOPSDevice[k]) { // not required
			continue
		}
		if val, ok := o.ThrottleReadIOPSDevice[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateThrottleWriteBpsDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.ThrottleWriteBpsDevice) { // not required
		return nil
	}

	for k := range o.ThrottleWriteBpsDevice {

		if swag.IsZero(o.ThrottleWriteBpsDevice[k]) { // not required
			continue
		}
		if val, ok := o.ThrottleWriteBpsDevice[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateThrottleWriteIOPSDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.ThrottleWriteIOPSDevice) { // not required
		return nil
	}

	for k := range o.ThrottleWriteIOPSDevice {

		if swag.IsZero(o.ThrottleWriteIOPSDevice[k]) { // not required
			continue
		}
		if val, ok := o.ThrottleWriteIOPSDevice[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(o.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(o.Volumes); i++ {
		if swag.IsZero(o.Volumes[i]) { // not required
			continue
		}

		if o.Volumes[i] != nil {
			if err := o.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateWeightDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.WeightDevice) { // not required
		return nil
	}

	for k := range o.WeightDevice {

		if swag.IsZero(o.WeightDevice[k]) { // not required
			continue
		}
		if val, ok := o.WeightDevice[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) validateCgroupns(formats strfmt.Registry) error {
	if swag.IsZero(o.Cgroupns) { // not required
		return nil
	}

	if o.Cgroupns != nil {
		if err := o.Cgroupns.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "cgroupns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validateHealthconfig(formats strfmt.Registry) error {
	if swag.IsZero(o.Healthconfig) { // not required
		return nil
	}

	if o.Healthconfig != nil {
		if err := o.Healthconfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "healthconfig")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validateIdmappings(formats strfmt.Registry) error {
	if swag.IsZero(o.Idmappings) { // not required
		return nil
	}

	if o.Idmappings != nil {
		if err := o.Idmappings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "idmappings")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validateIpcns(formats strfmt.Registry) error {
	if swag.IsZero(o.Ipcns) { // not required
		return nil
	}

	if o.Ipcns != nil {
		if err := o.Ipcns.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "ipcns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validateLogConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(o.LogConfiguration) { // not required
		return nil
	}

	if o.LogConfiguration != nil {
		if err := o.LogConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "log_configuration")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validateNetns(formats strfmt.Registry) error {
	if swag.IsZero(o.Netns) { // not required
		return nil
	}

	if o.Netns != nil {
		if err := o.Netns.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "netns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validatePidns(formats strfmt.Registry) error {
	if swag.IsZero(o.Pidns) { // not required
		return nil
	}

	if o.Pidns != nil {
		if err := o.Pidns.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "pidns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validateResourceLimits(formats strfmt.Registry) error {
	if swag.IsZero(o.ResourceLimits) { // not required
		return nil
	}

	if o.ResourceLimits != nil {
		if err := o.ResourceLimits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validateUserns(formats strfmt.Registry) error {
	if swag.IsZero(o.Userns) { // not required
		return nil
	}

	if o.Userns != nil {
		if err := o.Userns.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "userns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) validateUtsns(formats strfmt.Registry) error {
	if swag.IsZero(o.Utsns) { // not required
		return nil
	}

	if o.Utsns != nil {
		if err := o.Utsns.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "utsns")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this libpod create container body based on the context it is used
func (o *LibpodCreateContainerBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDevices(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOverlayVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePortMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRlimits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateThrottleReadBpsDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateThrottleReadIOPSDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateThrottleWriteBpsDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateThrottleWriteIOPSDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateWeightDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCgroupns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateHealthconfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIdmappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIpcns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLogConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNetns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePidns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateResourceLimits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateUserns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateUtsns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerBody) contextValidateDevices(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Devices); i++ {

		if o.Devices[i] != nil {
			if err := o.Devices[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateMounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Mounts); i++ {

		if o.Mounts[i] != nil {
			if err := o.Mounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "mounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateOverlayVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.OverlayVolumes); i++ {

		if o.OverlayVolumes[i] != nil {
			if err := o.OverlayVolumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "overlay_volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidatePortMappings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PortMappings); i++ {

		if o.PortMappings[i] != nil {
			if err := o.PortMappings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "portmappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateRlimits(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Rlimits); i++ {

		if o.Rlimits[i] != nil {
			if err := o.Rlimits[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "r_limits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateThrottleReadBpsDevice(ctx context.Context, formats strfmt.Registry) error {

	for k := range o.ThrottleReadBpsDevice {

		if val, ok := o.ThrottleReadBpsDevice[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateThrottleReadIOPSDevice(ctx context.Context, formats strfmt.Registry) error {

	for k := range o.ThrottleReadIOPSDevice {

		if val, ok := o.ThrottleReadIOPSDevice[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateThrottleWriteBpsDevice(ctx context.Context, formats strfmt.Registry) error {

	for k := range o.ThrottleWriteBpsDevice {

		if val, ok := o.ThrottleWriteBpsDevice[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateThrottleWriteIOPSDevice(ctx context.Context, formats strfmt.Registry) error {

	for k := range o.ThrottleWriteIOPSDevice {

		if val, ok := o.ThrottleWriteIOPSDevice[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Volumes); i++ {

		if o.Volumes[i] != nil {
			if err := o.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateWeightDevice(ctx context.Context, formats strfmt.Registry) error {

	for k := range o.WeightDevice {

		if val, ok := o.WeightDevice[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateCgroupns(ctx context.Context, formats strfmt.Registry) error {

	if o.Cgroupns != nil {
		if err := o.Cgroupns.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "cgroupns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateHealthconfig(ctx context.Context, formats strfmt.Registry) error {

	if o.Healthconfig != nil {
		if err := o.Healthconfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "healthconfig")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateIdmappings(ctx context.Context, formats strfmt.Registry) error {

	if o.Idmappings != nil {
		if err := o.Idmappings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "idmappings")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateIpcns(ctx context.Context, formats strfmt.Registry) error {

	if o.Ipcns != nil {
		if err := o.Ipcns.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "ipcns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateLogConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if o.LogConfiguration != nil {
		if err := o.LogConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "log_configuration")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateNetns(ctx context.Context, formats strfmt.Registry) error {

	if o.Netns != nil {
		if err := o.Netns.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "netns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidatePidns(ctx context.Context, formats strfmt.Registry) error {

	if o.Pidns != nil {
		if err := o.Pidns.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "pidns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateResourceLimits(ctx context.Context, formats strfmt.Registry) error {

	if o.ResourceLimits != nil {
		if err := o.ResourceLimits.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateUserns(ctx context.Context, formats strfmt.Registry) error {

	if o.Userns != nil {
		if err := o.Userns.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "userns")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerBody) contextValidateUtsns(ctx context.Context, formats strfmt.Registry) error {

	if o.Utsns != nil {
		if err := o.Utsns.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "utsns")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerBody) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerConflictBody libpod create container conflict body
swagger:model LibpodCreateContainerConflictBody
*/
type LibpodCreateContainerConflictBody struct {

	// API root cause formatted for automated parsing
	// Example: API root cause
	Because string `json:"cause,omitempty"`

	// human error message, formatted for a human to read
	// Example: human error message
	Message string `json:"message,omitempty"`

	// http response code
	ResponseCode int64 `json:"response,omitempty"`
}

// Validate validates this libpod create container conflict body
func (o *LibpodCreateContainerConflictBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container conflict body based on context it is used
func (o *LibpodCreateContainerConflictBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerConflictBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerConflictBody) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerConflictBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerCreatedBody libpod create container created body
swagger:model LibpodCreateContainerCreatedBody
*/
type LibpodCreateContainerCreatedBody struct {

	// ID of the container created
	ID string `json:"Id,omitempty"`

	// Warnings during container creation
	Warnings []string `json:"Warnings"`
}

// Validate validates this libpod create container created body
func (o *LibpodCreateContainerCreatedBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container created body based on context it is used
func (o *LibpodCreateContainerCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerCreatedBody) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerInternalServerErrorBody libpod create container internal server error body
swagger:model LibpodCreateContainerInternalServerErrorBody
*/
type LibpodCreateContainerInternalServerErrorBody struct {

	// API root cause formatted for automated parsing
	// Example: API root cause
	Because string `json:"cause,omitempty"`

	// human error message, formatted for a human to read
	// Example: human error message
	Message string `json:"message,omitempty"`

	// http response code
	ResponseCode int64 `json:"response,omitempty"`
}

// Validate validates this libpod create container internal server error body
func (o *LibpodCreateContainerInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container internal server error body based on context it is used
func (o *LibpodCreateContainerInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerNotFoundBody libpod create container not found body
swagger:model LibpodCreateContainerNotFoundBody
*/
type LibpodCreateContainerNotFoundBody struct {

	// API root cause formatted for automated parsing
	// Example: API root cause
	Because string `json:"cause,omitempty"`

	// human error message, formatted for a human to read
	// Example: human error message
	Message string `json:"message,omitempty"`

	// http response code
	ResponseCode int64 `json:"response,omitempty"`
}

// Validate validates this libpod create container not found body
func (o *LibpodCreateContainerNotFoundBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container not found body based on context it is used
func (o *LibpodCreateContainerNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerNotFoundBody) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyCgroupns Namespace describes the namespace
swagger:model LibpodCreateContainerParamsBodyCgroupns
*/
type LibpodCreateContainerParamsBodyCgroupns struct {

	// value
	Value string `json:"string,omitempty"`

	// nsmode
	Nsmode string `json:"nsmode,omitempty"`
}

// Validate validates this libpod create container params body cgroupns
func (o *LibpodCreateContainerParamsBodyCgroupns) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body cgroupns based on context it is used
func (o *LibpodCreateContainerParamsBodyCgroupns) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyCgroupns) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyCgroupns) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyCgroupns
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyDevicesItems0 LinuxDevice represents the mknod information for a Linux special device file
swagger:model LibpodCreateContainerParamsBodyDevicesItems0
*/
type LibpodCreateContainerParamsBodyDevicesItems0 struct {

	// Gid of the device.
	GID uint32 `json:"gid,omitempty"`

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Path to the device.
	Path string `json:"path,omitempty"`

	// Device type, block, char, etc.
	Type string `json:"type,omitempty"`

	// UID of the device.
	UID uint32 `json:"uid,omitempty"`

	// A FileMode represents a file's mode and permission bits.
	//
	// The bits have the same definition on all systems, so that
	// information about files can be moved from one system
	// to another portably. Not all bits apply to all systems.
	// The only required bit is ModeDir for directories.
	FileMode uint32 `json:"fileMode,omitempty"`
}

// Validate validates this libpod create container params body devices items0
func (o *LibpodCreateContainerParamsBodyDevicesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body devices items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyDevicesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyDevicesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyDevicesItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyDevicesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyHealthconfig Schema2HealthConfig is a HealthConfig, which holds configuration settings
// for the HEALTHCHECK feature, from docker/docker/api/types/container.
swagger:model LibpodCreateContainerParamsBodyHealthconfig
*/
type LibpodCreateContainerParamsBodyHealthconfig struct {

	// Retries is the number of consecutive failures needed to consider a container as unhealthy.
	// Zero means inherit.
	Retries int64 `json:"Retries,omitempty"`

	// Test is the test to perform to check that the container is healthy.
	// An empty slice means to inherit the default.
	// The options are:
	// {} : inherit healthcheck
	// {"NONE"} : disable healthcheck
	// {"CMD", args...} : exec arguments directly
	// {"CMD-SHELL", command} : run command with system's default shell
	Test []string `json:"Test"`

	// A Duration represents the elapsed time between two instants
	// as an int64 nanosecond count. The representation limits the
	// largest representable duration to approximately 290 years.
	Interval int64 `json:"Interval,omitempty"`

	// A Duration represents the elapsed time between two instants
	// as an int64 nanosecond count. The representation limits the
	// largest representable duration to approximately 290 years.
	StartPeriod int64 `json:"StartPeriod,omitempty"`

	// A Duration represents the elapsed time between two instants
	// as an int64 nanosecond count. The representation limits the
	// largest representable duration to approximately 290 years.
	Timeout int64 `json:"Timeout,omitempty"`
}

// Validate validates this libpod create container params body healthconfig
func (o *LibpodCreateContainerParamsBodyHealthconfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body healthconfig based on context it is used
func (o *LibpodCreateContainerParamsBodyHealthconfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyHealthconfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyHealthconfig) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyHealthconfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyIdmappings IDMappingOptions are used for specifying how ID mapping should be set up for
// a layer or container.
swagger:model LibpodCreateContainerParamsBodyIdmappings
*/
type LibpodCreateContainerParamsBodyIdmappings struct {

	// auto user ns
	AutoUserNs bool `json:"AutoUserNs,omitempty"`

	// g ID map
	GIDMap []*LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0 `json:"GIDMap"`

	// host g ID mapping
	HostGIDMapping bool `json:"HostGIDMapping,omitempty"`

	// UIDMap and GIDMap are used for setting up a layer's root filesystem
	// for use inside of a user namespace where ID mapping is being used.
	// If HostUIDMapping/HostGIDMapping is true, no mapping of the
	// respective type will be used.  Otherwise, if UIDMap and/or GIDMap
	// contain at least one mapping, one or both will be used.  By default,
	// if neither of those conditions apply, if the layer has a parent
	// layer, the parent layer's mapping will be used, and if it does not
	// have a parent layer, the mapping which was passed to the Store
	// object when it was initialized will be used.
	HostUIDMapping bool `json:"HostUIDMapping,omitempty"`

	// UID map
	UIDMap []*LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0 `json:"UIDMap"`

	// auto user ns opts
	AutoUserNsOpts *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts `json:"AutoUserNsOpts,omitempty"`
}

// Validate validates this libpod create container params body idmappings
func (o *LibpodCreateContainerParamsBodyIdmappings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateGIDMap(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUIDMap(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAutoUserNsOpts(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappings) validateGIDMap(formats strfmt.Registry) error {
	if swag.IsZero(o.GIDMap) { // not required
		return nil
	}

	for i := 0; i < len(o.GIDMap); i++ {
		if swag.IsZero(o.GIDMap[i]) { // not required
			continue
		}

		if o.GIDMap[i] != nil {
			if err := o.GIDMap[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "idmappings" + "." + "GIDMap" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappings) validateUIDMap(formats strfmt.Registry) error {
	if swag.IsZero(o.UIDMap) { // not required
		return nil
	}

	for i := 0; i < len(o.UIDMap); i++ {
		if swag.IsZero(o.UIDMap[i]) { // not required
			continue
		}

		if o.UIDMap[i] != nil {
			if err := o.UIDMap[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "idmappings" + "." + "UIDMap" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappings) validateAutoUserNsOpts(formats strfmt.Registry) error {
	if swag.IsZero(o.AutoUserNsOpts) { // not required
		return nil
	}

	if o.AutoUserNsOpts != nil {
		if err := o.AutoUserNsOpts.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "idmappings" + "." + "AutoUserNsOpts")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this libpod create container params body idmappings based on the context it is used
func (o *LibpodCreateContainerParamsBodyIdmappings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateGIDMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateUIDMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAutoUserNsOpts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappings) contextValidateGIDMap(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.GIDMap); i++ {

		if o.GIDMap[i] != nil {
			if err := o.GIDMap[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "idmappings" + "." + "GIDMap" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappings) contextValidateUIDMap(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.UIDMap); i++ {

		if o.UIDMap[i] != nil {
			if err := o.UIDMap[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "idmappings" + "." + "UIDMap" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappings) contextValidateAutoUserNsOpts(ctx context.Context, formats strfmt.Registry) error {

	if o.AutoUserNsOpts != nil {
		if err := o.AutoUserNsOpts.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "idmappings" + "." + "AutoUserNsOpts")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappings) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappings) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyIdmappings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts AutoUserNsOptions defines how to automatically create a user namespace.
swagger:model LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts
*/
type LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts struct {

	// AdditionalGIDMappings specified additional GID mappings to include in
	// the generated user namespace.
	AdditionalGIDMappings []*LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0 `json:"AdditionalGIDMappings"`

	// AdditionalUIDMappings specified additional UID mappings to include in
	// the generated user namespace.
	AdditionalUIDMappings []*LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0 `json:"AdditionalUIDMappings"`

	// GroupFile to use if the container uses a volume.
	GroupFile string `json:"GroupFile,omitempty"`

	// InitialSize defines the minimum size for the user namespace.
	// The created user namespace will have at least this size.
	InitialSize uint32 `json:"InitialSize,omitempty"`

	// PasswdFile to use if the container uses a volume.
	PasswdFile string `json:"PasswdFile,omitempty"`

	// Size defines the size for the user namespace.  If it is set to a
	// value bigger than 0, the user namespace will have exactly this size.
	// If it is not set, some heuristics will be used to find its size.
	Size uint32 `json:"Size,omitempty"`
}

// Validate validates this libpod create container params body idmappings auto user ns opts
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalGIDMappings(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdditionalUIDMappings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts) validateAdditionalGIDMappings(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalGIDMappings) { // not required
		return nil
	}

	for i := 0; i < len(o.AdditionalGIDMappings); i++ {
		if swag.IsZero(o.AdditionalGIDMappings[i]) { // not required
			continue
		}

		if o.AdditionalGIDMappings[i] != nil {
			if err := o.AdditionalGIDMappings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "idmappings" + "." + "AutoUserNsOpts" + "." + "AdditionalGIDMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts) validateAdditionalUIDMappings(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalUIDMappings) { // not required
		return nil
	}

	for i := 0; i < len(o.AdditionalUIDMappings); i++ {
		if swag.IsZero(o.AdditionalUIDMappings[i]) { // not required
			continue
		}

		if o.AdditionalUIDMappings[i] != nil {
			if err := o.AdditionalUIDMappings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "idmappings" + "." + "AutoUserNsOpts" + "." + "AdditionalUIDMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this libpod create container params body idmappings auto user ns opts based on the context it is used
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAdditionalGIDMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAdditionalUIDMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts) contextValidateAdditionalGIDMappings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AdditionalGIDMappings); i++ {

		if o.AdditionalGIDMappings[i] != nil {
			if err := o.AdditionalGIDMappings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "idmappings" + "." + "AutoUserNsOpts" + "." + "AdditionalGIDMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts) contextValidateAdditionalUIDMappings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AdditionalUIDMappings); i++ {

		if o.AdditionalUIDMappings[i] != nil {
			if err := o.AdditionalUIDMappings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "idmappings" + "." + "AutoUserNsOpts" + "." + "AdditionalUIDMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOpts
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0 IDMap contains a single entry for user namespace range remapping. An array
// of IDMap entries represents the structure that will be provided to the Linux
// kernel for creating a user namespace.
swagger:model LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0
*/
type LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0 struct {

	// container ID
	ContainerID int64 `json:"container_id,omitempty"`

	// host ID
	HostID int64 `json:"host_id,omitempty"`

	// size
	Size int64 `json:"size,omitempty"`
}

// Validate validates this libpod create container params body idmappings auto user ns opts additional g ID mappings items0
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body idmappings auto user ns opts additional g ID mappings items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalGIDMappingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0 IDMap contains a single entry for user namespace range remapping. An array
// of IDMap entries represents the structure that will be provided to the Linux
// kernel for creating a user namespace.
swagger:model LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0
*/
type LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0 struct {

	// container ID
	ContainerID int64 `json:"container_id,omitempty"`

	// host ID
	HostID int64 `json:"host_id,omitempty"`

	// size
	Size int64 `json:"size,omitempty"`
}

// Validate validates this libpod create container params body idmappings auto user ns opts additional UID mappings items0
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body idmappings auto user ns opts additional UID mappings items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyIdmappingsAutoUserNsOptsAdditionalUIDMappingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0 IDMap contains a single entry for user namespace range remapping. An array
// of IDMap entries represents the structure that will be provided to the Linux
// kernel for creating a user namespace.
swagger:model LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0
*/
type LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0 struct {

	// container ID
	ContainerID int64 `json:"container_id,omitempty"`

	// host ID
	HostID int64 `json:"host_id,omitempty"`

	// size
	Size int64 `json:"size,omitempty"`
}

// Validate validates this libpod create container params body idmappings g ID map items0
func (o *LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body idmappings g ID map items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyIdmappingsGIDMapItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0 IDMap contains a single entry for user namespace range remapping. An array
// of IDMap entries represents the structure that will be provided to the Linux
// kernel for creating a user namespace.
swagger:model LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0
*/
type LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0 struct {

	// container ID
	ContainerID int64 `json:"container_id,omitempty"`

	// host ID
	HostID int64 `json:"host_id,omitempty"`

	// size
	Size int64 `json:"size,omitempty"`
}

// Validate validates this libpod create container params body idmappings UID map items0
func (o *LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body idmappings UID map items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyIdmappingsUIDMapItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyIpcns Namespace describes the namespace
swagger:model LibpodCreateContainerParamsBodyIpcns
*/
type LibpodCreateContainerParamsBodyIpcns struct {

	// value
	Value string `json:"string,omitempty"`

	// nsmode
	Nsmode string `json:"nsmode,omitempty"`
}

// Validate validates this libpod create container params body ipcns
func (o *LibpodCreateContainerParamsBodyIpcns) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body ipcns based on context it is used
func (o *LibpodCreateContainerParamsBodyIpcns) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIpcns) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyIpcns) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyIpcns
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyLogConfiguration LogConfig describes the logging characteristics for a container
swagger:model LibpodCreateContainerParamsBodyLogConfiguration
*/
type LibpodCreateContainerParamsBodyLogConfiguration struct {

	// LogDriver is the container's log driver.
	// Optional.
	Driver string `json:"driver,omitempty"`

	// A set of options to accompany the log driver.
	// Optional.
	Options map[string]string `json:"options,omitempty"`

	// LogPath is the path the container's logs will be stored at.
	// Only available if LogDriver is set to "json-file" or "k8s-file".
	// Optional.
	Path string `json:"path,omitempty"`
}

// Validate validates this libpod create container params body log configuration
func (o *LibpodCreateContainerParamsBodyLogConfiguration) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body log configuration based on context it is used
func (o *LibpodCreateContainerParamsBodyLogConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyLogConfiguration) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyLogConfiguration) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyLogConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyMountsItems0 Mount specifies a mount for a container.
swagger:model LibpodCreateContainerParamsBodyMountsItems0
*/
type LibpodCreateContainerParamsBodyMountsItems0 struct {

	// Destination is the absolute path where the mount will be placed in the container.
	Destination string `json:"destination,omitempty"`

	// Options are fstab style mount options.
	Options []string `json:"options"`

	// Source specifies the source path of the mount.
	Source string `json:"source,omitempty"`

	// Type specifies the mount kind.
	Type string `json:"type,omitempty"`
}

// Validate validates this libpod create container params body mounts items0
func (o *LibpodCreateContainerParamsBodyMountsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body mounts items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyMountsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyMountsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyMountsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyMountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyNetns Namespace describes the namespace
swagger:model LibpodCreateContainerParamsBodyNetns
*/
type LibpodCreateContainerParamsBodyNetns struct {

	// value
	Value string `json:"string,omitempty"`

	// nsmode
	Nsmode string `json:"nsmode,omitempty"`
}

// Validate validates this libpod create container params body netns
func (o *LibpodCreateContainerParamsBodyNetns) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body netns based on context it is used
func (o *LibpodCreateContainerParamsBodyNetns) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyNetns) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyNetns) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyNetns
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyOverlayVolumesItems0 OverlayVolume holds information about a overlay volume that will be mounted into
// the container.
swagger:model LibpodCreateContainerParamsBodyOverlayVolumesItems0
*/
type LibpodCreateContainerParamsBodyOverlayVolumesItems0 struct {

	// Destination is the absolute path where the mount will be placed in the container.
	Destination string `json:"destination,omitempty"`

	// Source specifies the source path of the mount.
	Source string `json:"source,omitempty"`
}

// Validate validates this libpod create container params body overlay volumes items0
func (o *LibpodCreateContainerParamsBodyOverlayVolumesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body overlay volumes items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyOverlayVolumesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyOverlayVolumesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyOverlayVolumesItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyOverlayVolumesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyPidns Namespace describes the namespace
swagger:model LibpodCreateContainerParamsBodyPidns
*/
type LibpodCreateContainerParamsBodyPidns struct {

	// value
	Value string `json:"string,omitempty"`

	// nsmode
	Nsmode string `json:"nsmode,omitempty"`
}

// Validate validates this libpod create container params body pidns
func (o *LibpodCreateContainerParamsBodyPidns) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body pidns based on context it is used
func (o *LibpodCreateContainerParamsBodyPidns) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyPidns) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyPidns) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyPidns
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyPortmappingsItems0 PortMapping is one or more ports that will be mapped into the container.
swagger:model LibpodCreateContainerParamsBodyPortmappingsItems0
*/
type LibpodCreateContainerParamsBodyPortmappingsItems0 struct {

	// ContainerPort is the port number that will be exposed from the
	// container.
	// Mandatory.
	ContainerPort uint16 `json:"container_port,omitempty"`

	// HostIP is the IP that we will bind to on the host.
	// If unset, assumed to be 0.0.0.0 (all interfaces).
	HostIP string `json:"host_ip,omitempty"`

	// HostPort is the port number that will be forwarded from the host into
	// the container.
	// If omitted, a random port on the host (guaranteed to be over 1024)
	// will be assigned.
	HostPort uint16 `json:"host_port,omitempty"`

	// Protocol is the protocol forward.
	// Must be either "tcp", "udp", and "sctp", or some combination of these
	// separated by commas.
	// If unset, assumed to be TCP.
	Protocol string `json:"protocol,omitempty"`

	// Range is the number of ports that will be forwarded, starting at
	// HostPort and ContainerPort and counting up.
	// This is 1-indexed, so 1 is assumed to be a single port (only the
	// Hostport:Containerport mapping will be added), 2 is two ports (both
	// Hostport:Containerport and Hostport+1:Containerport+1), etc.
	// If unset, assumed to be 1 (a single port).
	// Both hostport + range and containerport + range must be less than
	// 65536.
	Range uint16 `json:"range,omitempty"`
}

// Validate validates this libpod create container params body portmappings items0
func (o *LibpodCreateContainerParamsBodyPortmappingsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body portmappings items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyPortmappingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyPortmappingsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyPortmappingsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyPortmappingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyRLimitsItems0 POSIXRlimit type and restrictions
swagger:model LibpodCreateContainerParamsBodyRLimitsItems0
*/
type LibpodCreateContainerParamsBodyRLimitsItems0 struct {

	// Hard is the hard limit for the specified type
	Hard uint64 `json:"hard,omitempty"`

	// Soft is the soft limit for the specified type
	Soft uint64 `json:"soft,omitempty"`

	// Type of the rlimit to set
	Type string `json:"type,omitempty"`
}

// Validate validates this libpod create container params body r limits items0
func (o *LibpodCreateContainerParamsBodyRLimitsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body r limits items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyRLimitsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyRLimitsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyRLimitsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyRLimitsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimits LinuxResources has container runtime resource constraints
swagger:model LibpodCreateContainerParamsBodyResourceLimits
*/
type LibpodCreateContainerParamsBodyResourceLimits struct {

	// Devices configures the device allowlist.
	Devices []*LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0 `json:"devices"`

	// Hugetlb limit (in bytes)
	HugepageLimits []*LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0 `json:"hugepageLimits"`

	// Rdma resource restriction configuration.
	// Limits are a set of key value pairs that define RDMA resource limits,
	// where the key is device name and value is resource limits.
	Rdma map[string]LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon `json:"rdma,omitempty"`

	// Unified resources.
	Unified map[string]string `json:"unified,omitempty"`

	// block i o
	BlockIO *LibpodCreateContainerParamsBodyResourceLimitsBlockIO `json:"blockIO,omitempty"`

	// cpu
	CPU *LibpodCreateContainerParamsBodyResourceLimitsCPU `json:"cpu,omitempty"`

	// memory
	Memory *LibpodCreateContainerParamsBodyResourceLimitsMemory `json:"memory,omitempty"`

	// network
	Network *LibpodCreateContainerParamsBodyResourceLimitsNetwork `json:"network,omitempty"`

	// pids
	Pids *LibpodCreateContainerParamsBodyResourceLimitsPids `json:"pids,omitempty"`
}

// Validate validates this libpod create container params body resource limits
func (o *LibpodCreateContainerParamsBodyResourceLimits) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDevices(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHugepageLimits(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRdma(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBlockIO(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCPU(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMemory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePids(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) validateDevices(formats strfmt.Registry) error {
	if swag.IsZero(o.Devices) { // not required
		return nil
	}

	for i := 0; i < len(o.Devices); i++ {
		if swag.IsZero(o.Devices[i]) { // not required
			continue
		}

		if o.Devices[i] != nil {
			if err := o.Devices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) validateHugepageLimits(formats strfmt.Registry) error {
	if swag.IsZero(o.HugepageLimits) { // not required
		return nil
	}

	for i := 0; i < len(o.HugepageLimits); i++ {
		if swag.IsZero(o.HugepageLimits[i]) { // not required
			continue
		}

		if o.HugepageLimits[i] != nil {
			if err := o.HugepageLimits[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "hugepageLimits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) validateRdma(formats strfmt.Registry) error {
	if swag.IsZero(o.Rdma) { // not required
		return nil
	}

	for k := range o.Rdma {

		if swag.IsZero(o.Rdma[k]) { // not required
			continue
		}
		if val, ok := o.Rdma[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) validateBlockIO(formats strfmt.Registry) error {
	if swag.IsZero(o.BlockIO) { // not required
		return nil
	}

	if o.BlockIO != nil {
		if err := o.BlockIO.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) validateCPU(formats strfmt.Registry) error {
	if swag.IsZero(o.CPU) { // not required
		return nil
	}

	if o.CPU != nil {
		if err := o.CPU.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "cpu")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) validateMemory(formats strfmt.Registry) error {
	if swag.IsZero(o.Memory) { // not required
		return nil
	}

	if o.Memory != nil {
		if err := o.Memory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "memory")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) validateNetwork(formats strfmt.Registry) error {
	if swag.IsZero(o.Network) { // not required
		return nil
	}

	if o.Network != nil {
		if err := o.Network.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "network")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) validatePids(formats strfmt.Registry) error {
	if swag.IsZero(o.Pids) { // not required
		return nil
	}

	if o.Pids != nil {
		if err := o.Pids.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "pids")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this libpod create container params body resource limits based on the context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimits) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDevices(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateHugepageLimits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRdma(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBlockIO(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCPU(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMemory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNetwork(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePids(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) contextValidateDevices(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Devices); i++ {

		if o.Devices[i] != nil {
			if err := o.Devices[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) contextValidateHugepageLimits(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.HugepageLimits); i++ {

		if o.HugepageLimits[i] != nil {
			if err := o.HugepageLimits[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "hugepageLimits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) contextValidateRdma(ctx context.Context, formats strfmt.Registry) error {

	for k := range o.Rdma {

		if val, ok := o.Rdma[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) contextValidateBlockIO(ctx context.Context, formats strfmt.Registry) error {

	if o.BlockIO != nil {
		if err := o.BlockIO.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) contextValidateCPU(ctx context.Context, formats strfmt.Registry) error {

	if o.CPU != nil {
		if err := o.CPU.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "cpu")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) contextValidateMemory(ctx context.Context, formats strfmt.Registry) error {

	if o.Memory != nil {
		if err := o.Memory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "memory")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) contextValidateNetwork(ctx context.Context, formats strfmt.Registry) error {

	if o.Network != nil {
		if err := o.Network.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "network")
			}
			return err
		}
	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimits) contextValidatePids(ctx context.Context, formats strfmt.Registry) error {

	if o.Pids != nil {
		if err := o.Pids.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("create" + "." + "resource_limits" + "." + "pids")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimits) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimits) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimits
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsBlockIO LinuxBlockIO for Linux cgroup 'blkio' resource management
swagger:model LibpodCreateContainerParamsBodyResourceLimitsBlockIO
*/
type LibpodCreateContainerParamsBodyResourceLimitsBlockIO struct {

	// Specifies tasks' weight in the given cgroup while competing with the cgroup's child cgroups, CFQ scheduler only
	LeafWeight uint16 `json:"leafWeight,omitempty"`

	// IO read rate limit per cgroup per device, bytes per second
	ThrottleReadBpsDevice []*LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0 `json:"throttleReadBpsDevice"`

	// IO read rate limit per cgroup per device, IO per second
	ThrottleReadIOPSDevice []*LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0 `json:"throttleReadIOPSDevice"`

	// IO write rate limit per cgroup per device, bytes per second
	ThrottleWriteBpsDevice []*LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0 `json:"throttleWriteBpsDevice"`

	// IO write rate limit per cgroup per device, IO per second
	ThrottleWriteIOPSDevice []*LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0 `json:"throttleWriteIOPSDevice"`

	// Specifies per cgroup weight
	Weight uint16 `json:"weight,omitempty"`

	// Weight per cgroup per device, can override BlkioWeight
	WeightDevice []*LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0 `json:"weightDevice"`
}

// Validate validates this libpod create container params body resource limits block i o
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateThrottleReadBpsDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThrottleReadIOPSDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThrottleWriteBpsDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThrottleWriteIOPSDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightDevice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) validateThrottleReadBpsDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.ThrottleReadBpsDevice) { // not required
		return nil
	}

	for i := 0; i < len(o.ThrottleReadBpsDevice); i++ {
		if swag.IsZero(o.ThrottleReadBpsDevice[i]) { // not required
			continue
		}

		if o.ThrottleReadBpsDevice[i] != nil {
			if err := o.ThrottleReadBpsDevice[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "throttleReadBpsDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) validateThrottleReadIOPSDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.ThrottleReadIOPSDevice) { // not required
		return nil
	}

	for i := 0; i < len(o.ThrottleReadIOPSDevice); i++ {
		if swag.IsZero(o.ThrottleReadIOPSDevice[i]) { // not required
			continue
		}

		if o.ThrottleReadIOPSDevice[i] != nil {
			if err := o.ThrottleReadIOPSDevice[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "throttleReadIOPSDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) validateThrottleWriteBpsDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.ThrottleWriteBpsDevice) { // not required
		return nil
	}

	for i := 0; i < len(o.ThrottleWriteBpsDevice); i++ {
		if swag.IsZero(o.ThrottleWriteBpsDevice[i]) { // not required
			continue
		}

		if o.ThrottleWriteBpsDevice[i] != nil {
			if err := o.ThrottleWriteBpsDevice[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "throttleWriteBpsDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) validateThrottleWriteIOPSDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.ThrottleWriteIOPSDevice) { // not required
		return nil
	}

	for i := 0; i < len(o.ThrottleWriteIOPSDevice); i++ {
		if swag.IsZero(o.ThrottleWriteIOPSDevice[i]) { // not required
			continue
		}

		if o.ThrottleWriteIOPSDevice[i] != nil {
			if err := o.ThrottleWriteIOPSDevice[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "throttleWriteIOPSDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) validateWeightDevice(formats strfmt.Registry) error {
	if swag.IsZero(o.WeightDevice) { // not required
		return nil
	}

	for i := 0; i < len(o.WeightDevice); i++ {
		if swag.IsZero(o.WeightDevice[i]) { // not required
			continue
		}

		if o.WeightDevice[i] != nil {
			if err := o.WeightDevice[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "weightDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this libpod create container params body resource limits block i o based on the context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateThrottleReadBpsDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateThrottleReadIOPSDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateThrottleWriteBpsDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateThrottleWriteIOPSDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateWeightDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) contextValidateThrottleReadBpsDevice(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ThrottleReadBpsDevice); i++ {

		if o.ThrottleReadBpsDevice[i] != nil {
			if err := o.ThrottleReadBpsDevice[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "throttleReadBpsDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) contextValidateThrottleReadIOPSDevice(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ThrottleReadIOPSDevice); i++ {

		if o.ThrottleReadIOPSDevice[i] != nil {
			if err := o.ThrottleReadIOPSDevice[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "throttleReadIOPSDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) contextValidateThrottleWriteBpsDevice(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ThrottleWriteBpsDevice); i++ {

		if o.ThrottleWriteBpsDevice[i] != nil {
			if err := o.ThrottleWriteBpsDevice[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "throttleWriteBpsDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) contextValidateThrottleWriteIOPSDevice(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ThrottleWriteIOPSDevice); i++ {

		if o.ThrottleWriteIOPSDevice[i] != nil {
			if err := o.ThrottleWriteIOPSDevice[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "throttleWriteIOPSDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) contextValidateWeightDevice(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.WeightDevice); i++ {

		if o.WeightDevice[i] != nil {
			if err := o.WeightDevice[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "blockIO" + "." + "weightDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIO) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsBlockIO
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0 LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
swagger:model LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0
*/
type LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0 struct {

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `json:"rate,omitempty"`
}

// Validate validates this libpod create container params body resource limits block i o throttle read bps device items0
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits block i o throttle read bps device items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadBpsDeviceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0 LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
swagger:model LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0
*/
type LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0 struct {

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `json:"rate,omitempty"`
}

// Validate validates this libpod create container params body resource limits block i o throttle read i o p s device items0
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits block i o throttle read i o p s device items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleReadIOPSDeviceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0 LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
swagger:model LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0
*/
type LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0 struct {

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `json:"rate,omitempty"`
}

// Validate validates this libpod create container params body resource limits block i o throttle write bps device items0
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits block i o throttle write bps device items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteBpsDeviceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0 LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
swagger:model LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0
*/
type LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0 struct {

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `json:"rate,omitempty"`
}

// Validate validates this libpod create container params body resource limits block i o throttle write i o p s device items0
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits block i o throttle write i o p s device items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsBlockIOThrottleWriteIOPSDeviceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0 LinuxWeightDevice struct holds a `major:minor weight` pair for weightDevice
swagger:model LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0
*/
type LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0 struct {

	// LeafWeight is the bandwidth rate for the device while competing with the cgroup's child cgroups, CFQ scheduler only
	LeafWeight uint16 `json:"leafWeight,omitempty"`

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Weight is the bandwidth rate for the device.
	Weight uint16 `json:"weight,omitempty"`
}

// Validate validates this libpod create container params body resource limits block i o weight device items0
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits block i o weight device items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsBlockIOWeightDeviceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsCPU LinuxCPU for Linux cgroup 'cpu' resource management
swagger:model LibpodCreateContainerParamsBodyResourceLimitsCPU
*/
type LibpodCreateContainerParamsBodyResourceLimitsCPU struct {

	// CPUs to use within the cpuset. Default is to use any CPU available.
	Cpus string `json:"cpus,omitempty"`

	// List of memory nodes in the cpuset. Default is to use any available memory node.
	Mems string `json:"mems,omitempty"`

	// CPU period to be used for hardcapping (in usecs).
	Period uint64 `json:"period,omitempty"`

	// CPU hardcap limit (in usecs). Allowed cpu time in a given period.
	Quota int64 `json:"quota,omitempty"`

	// CPU period to be used for realtime scheduling (in usecs).
	RealtimePeriod uint64 `json:"realtimePeriod,omitempty"`

	// How much time realtime scheduling may use (in usecs).
	RealtimeRuntime int64 `json:"realtimeRuntime,omitempty"`

	// CPU shares (relative weight (ratio) vs. other cgroups with cpu shares).
	Shares uint64 `json:"shares,omitempty"`
}

// Validate validates this libpod create container params body resource limits CPU
func (o *LibpodCreateContainerParamsBodyResourceLimitsCPU) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits CPU based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsCPU) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsCPU) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsCPU) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsCPU
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0 LinuxDeviceCgroup represents a device rule for the devices specified to
// the device controller
swagger:model LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0
*/
type LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0 struct {

	// Cgroup access permissions format, rwm.
	Access string `json:"access,omitempty"`

	// Allow or deny
	Allow bool `json:"allow,omitempty"`

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Device type, block, char, etc.
	Type string `json:"type,omitempty"`
}

// Validate validates this libpod create container params body resource limits devices items0
func (o *LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits devices items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsDevicesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0 LinuxHugepageLimit structure corresponds to limiting kernel hugepages
swagger:model LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0
*/
type LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0 struct {

	// Limit is the limit of "hugepagesize" hugetlb usage
	Limit uint64 `json:"limit,omitempty"`

	// Pagesize is the hugepage size
	// Format: "<size><unit-prefix>B' (e.g. 64KB, 2MB, 1GB, etc.)
	Pagesize string `json:"pageSize,omitempty"`
}

// Validate validates this libpod create container params body resource limits hugepage limits items0
func (o *LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits hugepage limits items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsHugepageLimitsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsMemory LinuxMemory for Linux cgroup 'memory' resource management
swagger:model LibpodCreateContainerParamsBodyResourceLimitsMemory
*/
type LibpodCreateContainerParamsBodyResourceLimitsMemory struct {

	// DisableOOMKiller disables the OOM killer for out of memory conditions
	DisableOOMKiller bool `json:"disableOOMKiller,omitempty"`

	// Kernel memory limit (in bytes).
	Kernel int64 `json:"kernel,omitempty"`

	// Kernel memory limit for tcp (in bytes)
	KernelTCP int64 `json:"kernelTCP,omitempty"`

	// Memory limit (in bytes).
	Limit int64 `json:"limit,omitempty"`

	// Memory reservation or soft_limit (in bytes).
	Reservation int64 `json:"reservation,omitempty"`

	// Total memory limit (memory + swap).
	Swap int64 `json:"swap,omitempty"`

	// How aggressive the kernel will swap memory pages.
	Swappiness uint64 `json:"swappiness,omitempty"`

	// Enables hierarchical memory accounting
	UseHierarchy bool `json:"useHierarchy,omitempty"`
}

// Validate validates this libpod create container params body resource limits memory
func (o *LibpodCreateContainerParamsBodyResourceLimitsMemory) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits memory based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsMemory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsMemory) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsMemory) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsMemory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsNetwork LinuxNetwork identification and priority configuration
swagger:model LibpodCreateContainerParamsBodyResourceLimitsNetwork
*/
type LibpodCreateContainerParamsBodyResourceLimitsNetwork struct {

	// Set class identifier for container's network packets
	ClassID uint32 `json:"classID,omitempty"`

	// Set priority of network traffic for container
	Priorities []*LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0 `json:"priorities"`
}

// Validate validates this libpod create container params body resource limits network
func (o *LibpodCreateContainerParamsBodyResourceLimitsNetwork) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePriorities(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsNetwork) validatePriorities(formats strfmt.Registry) error {
	if swag.IsZero(o.Priorities) { // not required
		return nil
	}

	for i := 0; i < len(o.Priorities); i++ {
		if swag.IsZero(o.Priorities[i]) { // not required
			continue
		}

		if o.Priorities[i] != nil {
			if err := o.Priorities[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "network" + "." + "priorities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this libpod create container params body resource limits network based on the context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsNetwork) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePriorities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *LibpodCreateContainerParamsBodyResourceLimitsNetwork) contextValidatePriorities(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Priorities); i++ {

		if o.Priorities[i] != nil {
			if err := o.Priorities[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("create" + "." + "resource_limits" + "." + "network" + "." + "priorities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsNetwork) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsNetwork) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsNetwork
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0 LinuxInterfacePriority for network interfaces
swagger:model LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0
*/
type LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0 struct {

	// Name is the name of the network interface
	Name string `json:"name,omitempty"`

	// Priority for the interface
	Priority uint32 `json:"priority,omitempty"`
}

// Validate validates this libpod create container params body resource limits network priorities items0
func (o *LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits network priorities items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsNetworkPrioritiesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsPids LinuxPids for Linux cgroup 'pids' resource management (Linux 4.3)
swagger:model LibpodCreateContainerParamsBodyResourceLimitsPids
*/
type LibpodCreateContainerParamsBodyResourceLimitsPids struct {

	// Maximum number of PIDs. Default is "no limit".
	Limit int64 `json:"limit,omitempty"`
}

// Validate validates this libpod create container params body resource limits pids
func (o *LibpodCreateContainerParamsBodyResourceLimitsPids) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits pids based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsPids) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsPids) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsPids) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsPids
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon LinuxRdma for Linux cgroup 'rdma' resource management (Linux 4.11)
swagger:model LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon
*/
type LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon struct {

	// Maximum number of HCA handles that can be opened. Default is "no limit".
	HcaHandles uint32 `json:"hcaHandles,omitempty"`

	// Maximum number of HCA objects that can be created. Default is "no limit".
	HcaObjects uint32 `json:"hcaObjects,omitempty"`
}

// Validate validates this libpod create container params body resource limits rdma anon
func (o *LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body resource limits rdma anon based on context it is used
func (o *LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyResourceLimitsRdmaAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
swagger:model LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon
*/
type LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon struct {

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `json:"rate,omitempty"`
}

// Validate validates this libpod create container params body throttle read bps device anon
func (o *LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body throttle read bps device anon based on context it is used
func (o *LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyThrottleReadBpsDeviceAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
swagger:model LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon
*/
type LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon struct {

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `json:"rate,omitempty"`
}

// Validate validates this libpod create container params body throttle read i o p s device anon
func (o *LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body throttle read i o p s device anon based on context it is used
func (o *LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyThrottleReadIOPSDeviceAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
swagger:model LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon
*/
type LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon struct {

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `json:"rate,omitempty"`
}

// Validate validates this libpod create container params body throttle write bps device anon
func (o *LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body throttle write bps device anon based on context it is used
func (o *LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyThrottleWriteBpsDeviceAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
swagger:model LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon
*/
type LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon struct {

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `json:"rate,omitempty"`
}

// Validate validates this libpod create container params body throttle write i o p s device anon
func (o *LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body throttle write i o p s device anon based on context it is used
func (o *LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyThrottleWriteIOPSDeviceAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyUserns Namespace describes the namespace
swagger:model LibpodCreateContainerParamsBodyUserns
*/
type LibpodCreateContainerParamsBodyUserns struct {

	// value
	Value string `json:"string,omitempty"`

	// nsmode
	Nsmode string `json:"nsmode,omitempty"`
}

// Validate validates this libpod create container params body userns
func (o *LibpodCreateContainerParamsBodyUserns) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body userns based on context it is used
func (o *LibpodCreateContainerParamsBodyUserns) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyUserns) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyUserns) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyUserns
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyUtsns Namespace describes the namespace
swagger:model LibpodCreateContainerParamsBodyUtsns
*/
type LibpodCreateContainerParamsBodyUtsns struct {

	// value
	Value string `json:"string,omitempty"`

	// nsmode
	Nsmode string `json:"nsmode,omitempty"`
}

// Validate validates this libpod create container params body utsns
func (o *LibpodCreateContainerParamsBodyUtsns) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body utsns based on context it is used
func (o *LibpodCreateContainerParamsBodyUtsns) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyUtsns) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyUtsns) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyUtsns
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyVolumesItems0 NamedVolume holds information about a named volume that will be mounted into
// the container.
swagger:model LibpodCreateContainerParamsBodyVolumesItems0
*/
type LibpodCreateContainerParamsBodyVolumesItems0 struct {

	// Destination to mount the named volume within the container. Must be
	// an absolute path. Path will be created if it does not exist.
	Dest string `json:"Dest,omitempty"`

	// Name is the name of the named volume to be mounted. May be empty.
	// If empty, a new named volume with a pseudorandomly generated name
	// will be mounted at the given destination.
	Name string `json:"Name,omitempty"`

	// Options are options that the named volume will be mounted with.
	Options []string `json:"Options"`
}

// Validate validates this libpod create container params body volumes items0
func (o *LibpodCreateContainerParamsBodyVolumesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body volumes items0 based on context it is used
func (o *LibpodCreateContainerParamsBodyVolumesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyVolumesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyVolumesItems0) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyVolumesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*LibpodCreateContainerParamsBodyWeightDeviceAnon LinuxWeightDevice struct holds a `major:minor weight` pair for weightDevice
swagger:model LibpodCreateContainerParamsBodyWeightDeviceAnon
*/
type LibpodCreateContainerParamsBodyWeightDeviceAnon struct {

	// LeafWeight is the bandwidth rate for the device while competing with the cgroup's child cgroups, CFQ scheduler only
	LeafWeight uint16 `json:"leafWeight,omitempty"`

	// Major is the device's major number.
	Major int64 `json:"major,omitempty"`

	// Minor is the device's minor number.
	Minor int64 `json:"minor,omitempty"`

	// Weight is the bandwidth rate for the device.
	Weight uint16 `json:"weight,omitempty"`
}

// Validate validates this libpod create container params body weight device anon
func (o *LibpodCreateContainerParamsBodyWeightDeviceAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this libpod create container params body weight device anon based on context it is used
func (o *LibpodCreateContainerParamsBodyWeightDeviceAnon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyWeightDeviceAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *LibpodCreateContainerParamsBodyWeightDeviceAnon) UnmarshalBinary(b []byte) error {
	var res LibpodCreateContainerParamsBodyWeightDeviceAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
